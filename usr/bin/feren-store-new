#! /usr/bin/python3
# -*- coding:utf-8 -*-
#
# Copyright 2012-2013 "Korora Project" <dev@kororaproject.org>
# Copyright 2013 "Manjaro Linux" <support@manjaro.org>
# Copyright 2014 Antergos
# Copyright 2016-2020 Ubuntu Mate
# Copyright 2016-2018 Ubuntu Budgie Developers
# Copyright 2016-2020 Feren OS Developers
#
# feren-store is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Feren Welcome Screen is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Feren Welcome Screen. If not, see <http://www.gnu.org/licenses/>.
#

""" Store for Feren OS """

import gi

gi.require_version('WebKit2', '4.0')

import os
import subprocess
import sys
import urllib.request
import urllib.error
import webbrowser
import socket
import platform
import json
import shutil
import locale
import gettext
import getpass
import signal
import colorsys

from gi.repository import WebKit2, Gtk, Gio, Gdk, GLib, Pango, GObject, GdkPixbuf
from threading import Thread
from queue import Queue, Empty
from notify2 import Notification, init as NotifyInit
from os.path import expanduser

from feren_store.aptmgmt import APTMgmt, APTChecks
from feren_store.icemgmt import ICEMgmt

global snapmgmtimported
global flatpakmgmtimported
snapmgmtimported = False
flatpakmgmtimported = False
global SnapMgmt
global SnapChecks
global FlatpakMgmt
global FlatpakChecks

import apt

####JSON Reader
class JSONReader():
    '''
    Map some short codes with packages. Install/Remove buttons
    will be represented by short code like #code-remove and
    #code-install. This will allow one to check installation status
    of each package using a loop instead of checking separately
    '''

    def __init__(self):
        import locale #Move this to the top of the code if it's ever needed elsewhere
        locale = locale.getlocale()[0]
        with open("/usr/share/feren-store-new/curated/store-internalnames/packages.json") as file:
            self.internalpkgnames = json.load(file)
        try:
            with open("/usr/share/feren-store-new/curated/"+locale+"/apt/packages.json") as file:
                self.aptdata = json.load(file)
        except:
            with open("/usr/share/feren-store-new/curated/generic/apt/packages.json") as file:
                self.aptdata = json.load(file)
        try:
            with open("/usr/share/feren-store-new/curated/"+locale+"/snap/packages.json") as file:
                self.snapdata = json.load(file)
        except:
            with open("/usr/share/feren-store-new/curated/generic/snap/packages.json") as file:
                self.snapdata = json.load(file)
        try:
            with open("/usr/share/feren-store-new/curated/"+locale+"/flatpak/packages.json") as file:
                self.flatpakdata = json.load(file)
        except:
            with open("/usr/share/feren-store-new/curated/generic/flatpak/packages.json") as file:
                self.flatpakdata = json.load(file)
        try:
            with open("/usr/share/feren-store-new/curated/"+locale+"/ice/websites.json") as file:
                self.icedata = json.load(file)
        except:
            with open("/usr/share/feren-store-new/curated/generic/ice/websites.json") as file:
                self.icedata = json.load(file)
        with open("/usr/share/feren-store-new/curated/sources/packages.json") as file:
            self.availablesources = json.load(file)
        try:
            with open("/usr/share/feren-store-new/curated/"+locale+"/package-generic-data.json") as file:
                self.genericpkgdata = json.load(file)
        except:
            with open("/usr/share/feren-store-new/curated/generic/package-generic-data.json") as file:
                self.genericpkgdata = json.load(file)

    def getNameFromInternal(self, internalname, pkgtype):
        try:
            return self.internalpkgnames[internalname][pkgtype]
        except:
            return None

    def getInternalFromName(self, packagename, pkgtype):
        try:
            for pkg in self.internalpkgnames:
                if self.internalpkgnames[pkg][pkgtype] == packagename:
                    return pkg
            return None
        except:
            return None

    def getPackageInfo(self, packagename, pkgtype):
        try:
            # I did consider having these be split information-wise, but then I thought better of that because of the fact packages are usually too similar throughout package types to warrant unique names and descriptions.
            if pkgtype == "apt" or pkgtype == "snap" or pkgtype == "flatpak":
                return self.genericpkgdata[packagename]["realname"], self.genericpkgdata[packagename]["shortdescription"], self.genericpkgdata[packagename]["iconurl"]
            elif pkgtype == "ice":
                return self.icedata[packagename]["realname"], "Web Application", self.icedata[packagename]["iconurl"]
            else:
                return None, None, None
        except KeyError:
            return None, None, None
        
    def getPackageSiteInfo(self, packagename, pkgtype):
        translatedpackagename = self.getNameFromInternal(packagename, pkgtype)
        try:
            if pkgtype == "apt":
                return self.genericpkgdata[packagename]["description"], self.aptdata[translatedpackagename]["author"], self.aptdata[translatedpackagename]["bugreporturl"], self.genericpkgdata[packagename]["website"], self.genericpkgdata[packagename]["donation"], self.aptdata[translatedpackagename]["tos"], self.aptdata[translatedpackagename]["privpol"], self.genericpkgdata[packagename]["category"], self.genericpkgdata[packagename]["image1"], self.genericpkgdata[packagename]["image2"], self.genericpkgdata[packagename]["image3"]
            elif pkgtype == "snap":
                return self.genericpkgdata[packagename]["description"], self.snapdata[translatedpackagename]["author"], self.snapdata[translatedpackagename]["bugreporturl"], self.genericpkgdata[packagename]["website"], self.genericpkgdata[packagename]["website"], self.snapdata[translatedpackagename]["tos"], self.snapdata[translatedpackagename]["privpol"], self.genericpkgdata[packagename]["category"], self.genericpkgdata[packagename]["image1"], self.genericpkgdata[packagename]["image2"], self.genericpkgdata[packagename]["image3"]
            elif pkgtype == "flatpak":
                return self.genericpkgdata[packagename]["description"], self.flatpakdata[translatedpackagename]["author"], self.flatpakdata[translatedpackagename]["bugreporturl"], self.genericpkgdata[packagename]["website"], self.genericpkgdata[packagename]["website"], self.flatpakdata[translatedpackagename]["tos"], self.flatpakdata[translatedpackagename]["privpol"], self.genericpkgdata[packagename]["category"], self.genericpkgdata[packagename]["image1"], self.genericpkgdata[packagename]["image2"], self.genericpkgdata[packagename]["image3"]
            elif pkgtype == "ice":
                return self.icedata[packagename]["description"], None, None, self.icedata[packagename]["website"], None, None, None, self.icedata[packagename]["category"], self.icedata[packagename]["image1"], self.icedata[packagename]["image2"], self.icedata[packagename]["image3"]
        except KeyError:
            return None, None, None, None, None, None, None, None, None, None, None
        
####Source Names translator
class ApplicationSourceTranslator():
    #Class for all things translating an application source internal name into human readable, keyrings and repositories to add
    
    def TranslateToHumanReadable(self, appsourceintname):
        if appsourceintname == "standard":
            return "Standard Install"
        elif appsourceintname == "google-chrome":
            return "Google Chrome Repository"
        elif appsourceintname == "google-earth":
            return "Google Earth Repository"
        elif appsourceintname == "vivaldi":
            return "Vivaldi Repository"
        elif appsourceintname == "microsoft-edge":
            return "Microsoft Edge Repository"
        elif appsourceintname == "visual-studio":
            return "Visual Studio Repository"
        elif appsourceintname == "brave":
            return "Brave Browser Repository"
        elif appsourceintname == "opera":
            return "Opera Browser Repository"
        elif appsourceintname == "waterfox":
            return "Waterfox Repository"
        elif appsourceintname == "snapstore":
            return "Snapcraft"
        elif appsourceintname == "flatpak-flathub":
            return "Flathub"
        elif appsourceintname == "flatpak-appcenter":
            return "elementary AppCenter"
        else:
            return appsourceintname
        #TODO: Add more


####Get icon of any size
class RetrieveIconSize():
    #Credits to Linux Mint for this code
    def set_icon_string(icon_string, width):
        theme = Gtk.IconTheme.get_default()
        scalefactor = Gtk.Image().get_scale_factor()

        icon_width = width * scalefactor

        if theme.has_icon(icon_string):
            info = theme.lookup_icon_for_scale(icon_string,
                                               width,
                                               scalefactor,
                                               Gtk.IconLookupFlags.FORCE_SIZE)
            if info:
                return(info.get_filename())
            
            return(RetrieveIconSize().set_icon_string(FALLBACK_PACKAGE_ICON_PATH, self.icon_width, self.icon_width))
   

####Global Variables
class GlobalVariables(object):
    def __init__(self):
        self.storagetemplocation = "/tmp/feren-store-"+getpass.getuser()
        #Make the folder if it doesn't exist
        if not os.path.isdir("/tmp/feren-store-"+getpass.getuser()):
            os.mkdir("/tmp/feren-store-"+getpass.getuser())

        
####Application Playlists
#class ApplicationPlaylists():
    #TODO: Add Import and Export code
        
    
####GSettings Management - get and set values
#TODO: Check if we even need this class - might be an upstream module that we can just use instead
class GSettingsMgmt():
    def get_value():
        pass
    
    def set_value():
        pass


####Package Tiles
class PackageTile(Gtk.Button):
    def set_icon(self, iconuri, packagename, iconobj):
        tempdir = classnetwork.GlobalVariables.storagetemplocation
                
        desired_width = 48
        desired_height = 48
        try:
            if not iconuri.startswith("file://"):
                #Download the application icon
                if not os.path.isfile(tempdir+"/"+packagename+"-icon"):
                    urllib.request.urlretrieve(iconuri, tempdir+"/"+packagename+"-icon")
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(tempdir+"/"+packagename+"-icon")
            else:
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(iconuri.split('file://')[1])
        except Exception as exceptionstring:
            #TODO: Change to store-missing-icon
            icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/icons/Inspire/256/apps/feren-store.png")
        icon_pixbuf = icon_pixbuf.scale_simple(desired_width, desired_height, GdkPixbuf.InterpType.BILINEAR)
        iconobj.set_from_pixbuf(icon_pixbuf)

    def __init__(self, packagename, packagetype):
        classnetwork.TasksMgmt.candirecttopkg = True
        Gtk.Button.__init__(self)

        app_title, app_desc, app_iconurl = classnetwork.JSONReader.getPackageInfo(packagename, packagetype)
        if (app_title, app_desc, app_iconurl) == (None, None, None):
            if packagetype == "apt": #Assume it's a DEB file, though TODO change this to match for unknown packages that aren't DEBs as well if this ever supports showing all packages
                app_title, app_desc, app_iconurl = classnetwork.AppView._deb.pkgname, "Package File", "file://"+RetrieveIconSize.set_icon_string("application-x-deb", 256)
                classnetwork.TasksMgmt.candirecttopkg = False
            else:
                raise Exception("Couldn't get metadata for tile for", packagename, packagetype)

        label_name = Gtk.Label(app_title, xalign=0)
        label_name.get_style_context().add_class("14scale")

        label_summary = Gtk.Label(app_desc)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)

        #Make sure application name and short descriptions are left-aligned in there
        app_title_box = Gtk.Box()
        app_desc_box = Gtk.Box()
        app_title_box.pack_start(label_name, False, False, 0)
        app_desc_box.pack_start(label_summary, False, False, 0)

        #Make the column for application name and short description
        vbox.pack_start(app_title_box, False, False, 0)
        vbox.pack_end(app_desc_box, False, False, 0)
        
        #Stuff for centering items vertically
        centering_titledesc_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        centering_titledesc_box.set_center_widget(vbox)



        #Application Icon
        icon = Gtk.Image()
        icon.set_margin_top(4)
        icon.set_margin_bottom(4)

        self.set_icon(app_iconurl, packagename, icon)

        hbox = Gtk.Box()
        hbox.pack_start(icon, False, False, 4)
        hbox.pack_start(centering_titledesc_box, False, False, 8)

        self.add(hbox)


####Tasks System
class TasksMgmt(object):
    
    def __init__(self):
        self.currenttasks = []
        self.currenttask = ""
        self.dontcontinue = False
        self.inaction = False
        self.existingwidgets = []
        self.candirecttopkg = True
        
        GObject.threads_init()
        
    def add_task(self, newtask):
        if not newtask in self.currenttasks:
            self.currenttasks.append(newtask)
            self.gui_refresh_tasks()
        
    def start_now(self):
        #Code for initiating the installation process if it isn't already initialised
        if self.inaction == False:
            self.do_tasks()
        else:
            return
        
    def gui_refresh_tasks(self):
        thread = Thread(target=self._gui_refresh_tasks,
                        args=())
        thread.daemon = True
        thread.start()
    
    def _gui_refresh_tasks(self):
        #Tried threads - just crashes
        GLib.idle_add(self.__gui_refresh_tasks)
    
    def __gui_refresh_tasks(self):
        if len(self.currenttasks) >= 1:
            classnetwork.StoreWindow.status_btn.set_label(str(len(self.currenttasks)))
        else:
            classnetwork.StoreWindow.status_btn.set_label("")
        
        #Destoy the existing widgets
        for child in classnetwork.StoreWindow.tasksitems.get_children():
            classnetwork.StoreWindow.tasksitems.remove(child)
        
        self.existingwidgets = []
        
        for task in self.currenttasks:
            if task.startswith('apt:inst:'):
                packagenm = task.split('apt:inst:')[1]
                tile = PackageTile(packagenm, "apt")
            elif task.startswith('aptdeb:inst:'):
                packagenm = task.split('aptdeb:inst:')[1]
                tile = PackageTile(packagenm, "apt")
            elif task.startswith('apt:upgr:'):
                packagenm = task.split('apt:upgr:')[1]
                tile = PackageTile(packagenm, "apt")
            elif task.startswith('apt:rm:'):
                packagenm = task.split('apt:rm:')[1]
                tile = PackageTile(packagenm, "apt")
            elif task.startswith('flatpak:inst:'):
                packagenm = task.split('flatpak:inst:')[1]
                tile = PackageTile(packagenm, "flatpak")
            elif task.startswith('flatpak:upgr:'):
                packagenm = task.split('flatpak:upgr:')[1]
                tile = PackageTile(packagenm, "flatpak")
            elif task.startswith('flatpak:rm:'):
                packagenm = task.split('flatpak:rm:')[1]
                tile = PackageTile(packagenm, "flatpak")
            elif task.startswith('snap:inst:'):
                packagenm = task.split('snap:inst:')[1]
                tile = PackageTile(packagenm, "snap")
            elif task.startswith('snap:rm:'):
                packagenm = task.split('snap:rm:')[1]
                tile = PackageTile(packagenm, "snap")
            
            if not task.startswith('aptdeb:inst:') and self.candirecttopkg == True:
                tile.connect("clicked", classnetwork.AppView._btn_goto_packageview, packagenm)

            box = Gtk.FlowBoxChild(child=tile)
            box.show_all()
            classnetwork.StoreWindow.tasksitems.insert(box, -1)
            
        classnetwork.StoreWindow.tasksitems.show_all()
        classnetwork.StoreWindow.updatesitems.show_all()
        classnetwork.StoreWindow.installeditems.show_all()
        
    def gui_refresh_buttons(self):
        thread = Thread(target=self._gui_refresh_buttons,
                        args=())
        thread.daemon = True
        thread.start()
        
    def _gui_refresh_buttons(self):
        #Tried threads - just crashes
        GLib.idle_add(self.__gui_refresh_buttons)
        
    def __gui_refresh_buttons(self):
        pass
        
        
    def do_task(self, task):
        self.currenttask = task
        #Code for doing the task
        classnetwork.AppDetailsHeader.switch_source(classnetwork.AppDetailsHeader.current_package, classnetwork.AppDetailsHeader.current_package_type, False)
        if task.startswith("apt:inst:"):
            while classnetwork.APTMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('apt:inst:')[1], "apt")
            if package == None:
                package = task.split('apt:inst:')[1]

            classnetwork.APTMgmt.run_transaction(package, "install")

            self.currenttasks.remove(task)
            self.currenttask = ""

            #Import the Snap and Flatpak modules (or make them unimported) depending on the state of snapd and flatpak
            if classnetwork.JSONReader.getNameFromInternal(task.split('apt:inst:')[1], "apt") == "snapd":
                classnetwork.import_snap()
            if classnetwork.JSONReader.getNameFromInternal(task.split('apt:inst:')[1], "apt") == "flatpak":
                classnetwork.import_flatpak()
        elif task.startswith("aptdeb:inst:"):
            while classnetwork.APTMgmt.changesinaction == True:
                pass

            classnetwork.APTMgmt.run_transaction(task.split('aptdeb:inst:')[1], "install")

            self.currenttasks.remove(task)
            self.currenttask = ""

            #Import the Snap and Flatpak modules (or make them unimported) depending on the state of snapd and flatpak
            if classnetwork.JSONReader.getNameFromInternal(task.split('aptdeb:inst:')[1], "apt") == "snapd":
                classnetwork.import_snap()
            if classnetwork.JSONReader.getNameFromInternal(task.split('aptdeb:inst:')[1], "apt") == "flatpak":
                classnetwork.import_flatpak()
        elif task.startswith("apt:upgr:"):
            while classnetwork.APTMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('apt:upgr:')[1], "apt")
            if package == None:
                package = task.split('apt:upgr:')[1]
            
            classnetwork.APTMgmt.run_transaction(package, "upgrade")

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("apt:rm:"):
            while classnetwork.APTMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('apt:rm:')[1], "apt")
            if package == None:
                package = task.split('apt:rm:')[1]
            
            classnetwork.APTMgmt.run_transaction(package, "remove")
            
            self.currenttasks.remove(task)
            self.currenttask = ""

            #Import the Snap and Flatpak modules (or make them unimported) depending on the state of snapd and flatpak
            if classnetwork.JSONReader.getNameFromInternal(task.split('apt:rm:')[1], "apt") == "snapd":
                classnetwork.import_snap()
            if classnetwork.JSONReader.getNameFromInternal(task.split('apt:rm:')[1], "apt") == "flatpak":
                classnetwork.import_flatpak()
        elif task.startswith("flatpak:inst:"):
            while classnetwork.FlatpakMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('flatpak:inst:')[1], "flatpak")
            if package == None:
                package = task.split('flatpak:inst:')[1]
            
            classnetwork.FlatpakMgmt.run_transaction(package, classnetwork.JSONReader.availablesources[task.split('flatpak:inst:')[1]]["flatpak"].split("flatpak-")[1], "install")

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("flatpak:upgr:"):
            while classnetwork.FlatpakMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('flatpak:upgr:')[1], "flatpak")
            if package == None:
                package = task.split('flatpak:upgr:')[1]
            
            classnetwork.FlatpakMgmt.run_transaction(package, classnetwork.JSONReader.availablesources[task.split('flatpak:upgr:')[1]]["flatpak"].split("flatpak-")[1], "upgrade")

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("flatpak:rm:"):
            while classnetwork.FlatpakMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('flatpak:rm:')[1], "flatpak")
            if package == None:
                package = task.split('flatpak:rm:')[1]
            
            classnetwork.FlatpakMgmt.run_transaction(package, classnetwork.JSONReader.availablesources[task.split('flatpak:rm:')[1]]["flatpak"].split("flatpak-")[1], "remove")
            
            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("snap:inst:"):
            while classnetwork.SnapMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('snap:inst:')[1], "snap")
            if package == None:
                package = task.split('snap:inst:')[1]
            
            classnetwork.SnapMgmt.run_transaction(package, "install")

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("snap:upgr:"):
            while classnetwork.SnapMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('snap:upgr:')[1], "snap")
            if package == None:
                package = task.split('snap:upgr:')[1]
            
            classnetwork.SnapMgmt.run_transaction(package, "upgrade")

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("snap:rm:"):
            while classnetwork.SnapMgmt.changesinaction == True:
                pass

            package = classnetwork.JSONReader.getNameFromInternal(task.split('snap:rm:')[1], "snap")
            if package == None:
                package = task.split('snap:rm:')[1]
            
            classnetwork.SnapMgmt.run_transaction(package, "remove")
            
            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("apt:aptsource:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("flatpak:remote:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        
        classnetwork.AppDetailsHeader.app_mgmt_progress.set_fraction(0.0)
        classnetwork.AppDetailsHeader.switch_source(classnetwork.AppDetailsHeader.current_package, classnetwork.AppDetailsHeader.current_package_type, False)
        if classnetwork.AppDetailsHeader.current_package.startswith("feren-ice-ssb-"):
            classnetwork.AppDetailsHeader.get_sources(classnetwork.AppDetailsHeader.current_package) #Refresh browsers every time

    def do_tasks(self):
        if classnetwork.flatpakmgmtimported == True:
            #Lock userland setting while tasks are running.
            classnetwork.FlatpakMgmt.userlandlock = True
        self.inaction = True
        while self.currenttasks != []:
            self.do_task(self.currenttasks[0])
            self.gui_refresh_tasks()
            
        self.inaction = False
        if classnetwork.flatpakmgmtimported == True:
            #Unlock the setting now that tasks are done
            classnetwork.FlatpakMgmt.userlandlock = False
        
    def closing_check(self):
        if self.currenttasks != []:
            #Prevent closing and stop the tasks after the existing task is done, followed by closing Store
            pass
        

####Search Header
#class SearchHeader(Gtk.Box):
    #TODO: Add this
    

####Application Details Header
class AppDetailsHeader(Gtk.Box):

    def __init__(self):
        
        Gtk.Box.__init__(self)
        
        classnetwork.AppDetailsHeader = self
        
        self.get_style_context().add_class("only-toolbar")

        self.current_package_type = ""        
        
        box_application_namedesc = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        
        #Application Icon
        self.app_iconimg = Gtk.Image()
        self.app_iconimg_loading = Gtk.Spinner()
        self.app_iconimg_stack = Gtk.Stack()
        self.app_iconimg_loading_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.app_iconimg_loading_box.set_center_widget(self.app_iconimg_loading)
        self.app_iconimg_stack.add_named(self.app_iconimg_loading_box, "Loading")
        self.app_iconimg_stack.add_named(self.app_iconimg, "AppIcon")
        self.app_iconimg_stack.set_visible_child(self.app_iconimg)
        
        #Application Title
        self.app_title = Gtk.Label()
        self.app_title.get_style_context().add_class("14scale")
        
        #Application Description
        self.app_desc = Gtk.Label()

        #Sources labels
        self.sources_label_stack = Gtk.Stack()
        self.sources_label_package = Gtk.Label(label=("Source: "))
        self.sources_label_ice = Gtk.Label(label=("Browser: "))
        self.sources_label_stack.add_named(self.sources_label_package, "PackageSource")
        self.sources_label_stack.add_named(self.sources_label_ice, "IceSource")
        
        #Application Management Buttons
        self.app_mgmt_button = Gtk.Stack()
        self.app_mgmt_installbtn = Gtk.Button(label=("Install"))
        self.app_mgmt_installunavailbtn = Gtk.Button(label=("Install..."))
        self.app_mgmt_removebtn = Gtk.Button(label=("Remove"))
        self.app_mgmt_updatebtn = Gtk.Button(label=("Update"))
        self.app_mgmt_installbtn.get_style_context().add_class(Gtk.STYLE_CLASS_SUGGESTED_ACTION)
        self.app_mgmt_installunavailbtn.get_style_context().add_class(Gtk.STYLE_CLASS_SUGGESTED_ACTION)
        self.app_mgmt_updatebtn.get_style_context().add_class(Gtk.STYLE_CLASS_SUGGESTED_ACTION)
        self.app_mgmt_removebtn.get_style_context().add_class(Gtk.STYLE_CLASS_DESTRUCTIVE_ACTION)
        self.app_mgmt_preparingbtns = Gtk.Spinner()
        self.app_mgmt_button.add_named(self.app_mgmt_preparingbtns, "Preparing")
        self.app_mgmt_button.add_named(self.app_mgmt_installbtn, "Standard")
        self.app_mgmt_button.add_named(self.app_mgmt_installunavailbtn, "InstallRepo")
        self.app_mgmt_button.add_named(self.app_mgmt_removebtn, "Remove")
        self.app_mgmt_button.set_visible_child(self.app_mgmt_preparingbtns)
        #self.app_mgmt_preparingbtns.start()
        
        #Application Source Combobox
        self.app_source_dropdown_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        self.app_source_dropdown_box.pack_start(self.sources_label_stack, False, False, 0)
        self.app_source_dropdown = Gtk.ComboBox()
        #NOTE TO SELF: NEVER put this in the dropdown refreshing code - it'll cause duplicated labels
        cell = Gtk.CellRendererText()
        self.app_source_dropdown.pack_start(cell, True)
        self.app_source_dropdown.add_attribute(cell, "text", 0)
        self.app_source_dropdown.connect("changed", self.on_source_dropdown_changed)
        self.app_source_dropdown_box.pack_end(self.app_source_dropdown, False, False, 0)
        
        #Progress Bar
        self.app_mgmt_progress = Gtk.ProgressBar()
        self.app_mgmt_progress_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.app_mgmt_progress_box.set_center_widget(self.app_mgmt_progress)
        
        #Pending Status
        self.app_mgmt_pending_box = Gtk.Box(spacing=8)
        app_mgmt_pending_labelbox = Gtk.VBox()
        app_mgmt_pending_label = Gtk.Label(label="Queued")
        app_mgmt_pending_cancel = Gtk.Button(label="Cancel")
        app_mgmt_pending_cancel.connect('clicked', self.cancel_from_queue_pressed)
        app_mgmt_pending_labelbox.set_center_widget(app_mgmt_pending_label)
        self.app_mgmt_pending_box.pack_start(app_mgmt_pending_labelbox, False, False, 0)
        self.app_mgmt_pending_box.pack_end(app_mgmt_pending_cancel, False, False, 0)
        self.app_mgmt_button.add_named(self.app_mgmt_pending_box, "Pending")
        
        #Make sure application name and short descriptions are left-aligned in there
        app_title_box = Gtk.Box()
        app_desc_box = Gtk.Box()
        app_title_box.pack_start(self.app_title, False, False, 0)
        app_desc_box.pack_start(self.app_desc, False, False, 0)
        
        #Make the column for application name and short description
        box_application_namedesc.pack_start(app_title_box, False, False, 0)
        box_application_namedesc.pack_end(app_desc_box, False, False, 0)
        
        #Stuff for centering items vertically
        centering_titledesc_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        centering_titledesc_box.set_center_widget(box_application_namedesc)
        centering_btnactions_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        
        inside_btnactions_box = Gtk.Box()
        inside_btnactions_box.pack_start(self.app_source_dropdown_box, False, False, 4)
        inside_btnactions_box.pack_start(self.app_mgmt_progress_box, False, False, 4)
        inside_btnactions_box.pack_start(self.app_mgmt_updatebtn, False, False, 4)
        inside_btnactions_box.pack_start(self.app_mgmt_button, False, False, 4)
        
        centering_btnactions_box.set_center_widget(inside_btnactions_box)
        
        #Header building
        self.pack_start(self.app_iconimg_stack, False, False, 8)
        self.pack_start(centering_titledesc_box, False, True, 4)
        self.pack_end(centering_btnactions_box, False, True, 4)
        
        #Margins
        self.app_iconimg.set_margin_top(8)
        self.app_iconimg.set_margin_bottom(8)
        
        #Header image temp
        desired_width = 48
        desired_height = 48
        icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/feren-os/logos/blank.png")
        icon_pixbuf = icon_pixbuf.scale_simple(desired_width, desired_height, GdkPixbuf.InterpType.BILINEAR)
        self.app_iconimg.set_from_pixbuf(icon_pixbuf)
        
        #Button Assignment
        self.app_mgmt_installbtn.connect('clicked', self.install_pressed)
        self.app_mgmt_installunavailbtn.connect('clicked', self.install_with_source_pressed)
        self.app_mgmt_updatebtn.connect('clicked', self.update_pressed)
        self.app_mgmt_removebtn.connect('clicked', self.remove_pressed)
        
        #Variables
        self.current_package = ""
        self.sources_visible = True
        
        #Initialize Management
        self.APTMgmt = APTMgmt(classnetwork)
        classnetwork.APTMgmt = self.APTMgmt
        self.ICEMgmt = ICEMgmt(classnetwork)
        classnetwork.ICEMgmt = self.ICEMgmt

        self.app_mgmt_button.set_visible_child(self.app_mgmt_preparingbtns)
        self.app_mgmt_updatebtn.set_visible(False)
        
        GObject.threads_init()
        
    def set_current_package(self, packagename):
        self.current_package = packagename

    def show(self):
        self.set_visible(True)
    
    def hide(self):
        self.set_visible(False)
    
    def set_icon(self, iconuri, packagetoview):
        tempdir = classnetwork.GlobalVariables.storagetemplocation
        
        self.app_iconimg_loading.start()
        self.app_iconimg_stack.set_visible_child(self.app_iconimg_loading_box)
        #Set the icon shown on the package header
                
        desired_width = 48
        desired_height = 48
        try:
            if not iconuri.startswith("file://"):
                #Download the application icon
                if not os.path.isfile(tempdir+"/"+packagetoview+"-icon"):
                    urllib.request.urlretrieve(iconuri, tempdir+"/"+packagetoview+"-icon")
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(tempdir+"/"+packagetoview+"-icon")
            else:
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(iconuri.split('file://')[1])
        except Exception as exceptionstring:
            print("Could not retrieve icon for", packagetoview, "-", exceptionstring)
            #TODO: Change to store-missing-icon
            icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/icons/Inspire/256/apps/feren-store.png")
        icon_pixbuf = icon_pixbuf.scale_simple(desired_width, desired_height, GdkPixbuf.InterpType.BILINEAR)
        self.app_iconimg.set_from_pixbuf(icon_pixbuf)
        self.app_iconimg_stack.set_visible_child(self.app_iconimg)
        self.app_iconimg_loading.stop()
    
    def set_app_details(self, apprname, appshortdesc):
        #Set the application real name (apprname) and short description (appshortdesc) on the package header
        self.app_title.set_label(apprname)
        self.app_desc.set_label(appshortdesc)
    
    def set_package_type(self, packagesource):
        #Set the application source to the one selected in the source dropdown
        self.current_package_type = packagesource

    def get_package_type(self):
        return self.current_package_type
    
    def get_sources(self, package):
        iface_list_store = Gtk.ListStore(GObject.TYPE_STRING)
        amount_of_sources = 0

        if package.startswith("feren-ice-ssb-"):
            GLib.idle_add(self.sources_label_stack.set_visible_child, self.sources_label_ice)
            #TODO: Put preferred browser at top of list
            if os.path.isfile("/usr/bin/vivaldi-stable"):
                iface_list_store.append(["Vivaldi"])
                amount_of_sources += 1
            if os.path.isfile("/usr/bin/google-chrome"):
                iface_list_store.append(["Google Chrome"])
                amount_of_sources += 1
            if os.path.isfile("/usr/bin/chromium-browser"):
                iface_list_store.append(["Chromium"])
                amount_of_sources += 1
            if os.path.isfile("/usr/bin/firefox"):
                iface_list_store.append(["Mozilla Firefox"])
                amount_of_sources += 1
            if classnetwork.flatpakmgmtimported == True and os.path.isfile("/var/lib/flatpak/overrides/org.mozilla.firefox"):
                iface_list_store.append(["M.Firefox (Flathub)"]) #TODO: Add userland support here
                amount_of_sources += 1
            if os.path.isfile("/usr/bin/brave-browser"):
                iface_list_store.append(["Brave"])
                amount_of_sources += 1
        elif package == "debfile":
            friendlysourcename = ApplicationSourceTranslator().TranslateToHumanReadable("standard")
            if friendlysourcename:
                iface_list_store.append([friendlysourcename])
                amount_of_sources += 1
        else:
            GLib.idle_add(self.sources_label_stack.set_visible_child, self.sources_label_package)
            #Using the JSON Data from sources/packages.json, populate the sources dropdown according to what's available
            sourcenames, orderofsources = [classnetwork.JSONReader.availablesources[package]["apt"], classnetwork.JSONReader.availablesources[package]["flatpak"], classnetwork.JSONReader.availablesources[package]["snap"]], classnetwork.JSONReader.availablesources[package]["order-of-importance"]
            
            for sourcename in orderofsources:
                if sourcename == "apt":
                    #apt source
                    friendlysourcename = ApplicationSourceTranslator().TranslateToHumanReadable(sourcenames[0])
                    if friendlysourcename:
                        iface_list_store.append([friendlysourcename])
                        amount_of_sources += 1
                elif sourcename == "flatpak":
                    #flatpak source
                    friendlysourcename = ApplicationSourceTranslator().TranslateToHumanReadable(sourcenames[1])
                    if friendlysourcename:
                        iface_list_store.append([friendlysourcename])
                        amount_of_sources += 1
                elif sourcename == "snap":
                    #snap source
                    friendlysourcename = ApplicationSourceTranslator().TranslateToHumanReadable(sourcenames[2])
                    if friendlysourcename:
                        iface_list_store.append([friendlysourcename])
                        amount_of_sources += 1
        
        self.app_source_dropdown.set_model(iface_list_store)
        self.app_source_dropdown.set_active(0)
        if amount_of_sources <= 1:
            self.app_source_dropdown_box.set_visible(False)
            self.sources_visible = False
        else:
            self.app_source_dropdown_box.set_visible(True)
            self.sources_visible = True
            
    def change_button_state(self, newstate, disableremove):
        thread = Thread(target=self._change_button_state,
                        args=(newstate, disableremove))
        thread.daemon = True
        thread.start()
        
    def _change_button_state(self, newstate, disableremove):
        GLib.idle_add(self.__change_button_state, newstate, disableremove)
    
    def __change_button_state(self, newstate, disableremove):
        #Change button state between 4 states:
        #uninstalled: Install is visible
        #sourcemissing: Install... is visible
        #installed: Remove is visible
        #updatable: Update and Remove are visible
        
        self.app_mgmt_installbtn.set_sensitive(False)
        self.app_mgmt_installunavailbtn.set_sensitive(False)
        self.app_mgmt_removebtn.set_sensitive(False)
        self.app_mgmt_updatebtn.set_sensitive(False)
        
        if newstate == "loading":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_preparingbtns.start()
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_preparingbtns)
        elif newstate == "queued":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_preparingbtns.start()
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_pending_box)
        elif newstate == "busy":
            #TODO: Add cancel button for non-running tasks once the tasks system is implemented
            self.app_source_dropdown_box.set_visible(False)
            self.app_mgmt_progress_box.set_visible(True)
            self.app_mgmt_button.set_visible(False)
        elif newstate == "uninstalled":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_installbtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_installbtn)
            self.app_mgmt_preparingbtns.stop()
        elif newstate == "sourcemissing":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_installunavailbtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_installunavailbtn)
            self.app_mgmt_preparingbtns.stop()
        elif newstate == "installed":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            if disableremove == False:
                self.app_mgmt_removebtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_removebtn)
            self.app_mgmt_preparingbtns.stop()
        elif newstate == "updatable":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            if disableremove == False:
                self.app_mgmt_removebtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(True)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_removebtn)
            self.app_mgmt_preparingbtns.stop()

    def switch_source(self, package, packagetype, autosourceswitch=True):
        thread = Thread(target=self._switch_source,
                        args=(package, packagetype, autosourceswitch))
        thread.daemon = True
        thread.start()
        
    def on_source_dropdown_changed(self, combobox):
        if self.current_package == "debfile":
            self.current_package_type = "apt"
        elif self.current_package_type != "ice":
            self.current_package_type = classnetwork.JSONReader.availablesources[self.current_package]["order-of-importance"][combobox.get_active()]
        self.switch_source(self.current_package, self.current_package_type, False)

    def _switch_source(self, package, packagetype, autosourceswitch=True):
        if self.current_package == "":
            return #Don't do anything if we're not currently in the package view area
        print("Switch Source:", packagetype)
        # Don't refresh the source details, etc if we aren't looking at the package - it'll mess up the GUI otherwise as if this was ran for X package while viewing Y package it'd change some of the details shown for Y package to ones for X package on that source
        if self.current_package != package:
            return
        # If it's the current package but the dropdown isn't on this source, let's abort this code after triggering the part of this code that responds to dropdown value changes (thus making this run again) by changing the dropdown value to the right value
        if self.current_package_type != packagetype:
            if autosourceswitch == True:
                GLib.idle_add(self.app_source_dropdown.set_active(classnetwork.JSONReader.availablesources[package]["order-of-importance"].index(packagetype)))
            return

        #Now change the appropriate items of the page
        GLib.idle_add(classnetwork.AppView.update_insite_information, package, packagetype)


        #Get the state of the package for changing the buttons presented to the user accordingly - is it installed? does it need an update?
        #packagetype is whether it's native, snap, ice or flatpak
        if self.current_package_type != "ice" and self.current_package != "debfile":
            mgmtpkgname = classnetwork.JSONReader.getNameFromInternal(package, self.current_package_type)
        GLib.idle_add(self.change_button_state, "loading", False)
        if self.current_package_type == "apt" and self.current_package != "debfile":
            if classnetwork.TasksMgmt.currenttask.startswith("apt:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package):
                GLib.idle_add(self.change_button_state, "busy", False)
                return
            elif ("apt:inst:"+package in classnetwork.TasksMgmt.currenttasks or "apt:upgr:"+package in classnetwork.TasksMgmt.currenttasks or "apt:rm:"+package in classnetwork.TasksMgmt.currenttasks) and not (classnetwork.TasksMgmt.currenttask.startswith("apt:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package)):
                GLib.idle_add(self.change_button_state, "queued", False)
                return
            ifinstalled = APTChecks.checkinstalled(mgmtpkgname)
            if self.current_package == package:
                if ifinstalled == 1: #TODO: Change blacklisting of Remove functionality to if the package is in a list of them
                    GLib.idle_add(self.change_button_state, "installed", mgmtpkgname == "feren-store")
                    return
                elif ifinstalled == 3:
                    GLib.idle_add(self.change_button_state, "updatable", mgmtpkgname == "feren-store")
                    return
                elif ifinstalled == 404: #TODO: Move this to if it can't find any usable sources
                    print("Cannot find", mgmtpkgname)
                    GLib.idle_add(classnetwork.StoreWindow.pages.set_visible_child, classnetwork.StoreWindow.nfpage)
                    GLib.idle_add(self.hide)
                    return
                else:
                    if ifinstalled != 404 and APTChecks.checkneedsrepo(mgmtpkgname) != []:
                        GLib.idle_add(self.change_button_state, "sourcemissing", mgmtpkgname == "feren-store")
                        return
                    else:
                        GLib.idle_add(self.change_button_state, "uninstalled", False)
                        return
        elif self.current_package_type == "apt" and self.current_package == "debfile":
            mgmtpkgname = classnetwork.AppView._deb.pkgname
            if "aptdeb:inst:"+sys.argv[1] == classnetwork.TasksMgmt.currenttask or "apt:upgr:"+mgmtpkgname == classnetwork.TasksMgmt.currenttask or "apt:rm:"+mgmtpkgname == classnetwork.TasksMgmt.currenttask:
                GLib.idle_add(self.change_button_state, "busy", False)
                return
            elif "aptdeb:inst:"+sys.argv[1] in classnetwork.TasksMgmt.currenttasks or "apt:upgr:"+mgmtpkgname in classnetwork.TasksMgmt.currenttasks or "apt:rm:"+mgmtpkgname in classnetwork.TasksMgmt.currenttasks:
                GLib.idle_add(self.change_button_state, "queued", False)
                return
            ifinstalled = APTChecks.checkinstalled(mgmtpkgname)
            if self.current_package == package:
                if ifinstalled == 1: #TODO: Change blacklisting of Remove functionality to if the package is in a list of them
                    GLib.idle_add(self.change_button_state, "installed", mgmtpkgname == "feren-store")
                    return
                elif ifinstalled == 3:
                    GLib.idle_add(self.change_button_state, "updatable", mgmtpkgname == "feren-store")
                    return
                else:
                    if ifinstalled != 404 and APTChecks.checkneedsrepo(mgmtpkgname) != []: #TODO: Make checkneedsrepo support DEBs
                        GLib.idle_add(self.change_button_state, "sourcemissing", mgmtpkgname == "feren-store")
                        return
                    else:
                        GLib.idle_add(self.change_button_state, "uninstalled", False)
                        return
        
        
        elif self.current_package_type == "snap":
            if classnetwork.TasksMgmt.currenttask.startswith("snap:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package):
                GLib.idle_add(self.change_button_state, "busy", False)
                return
            elif ("snap:inst:"+package in classnetwork.TasksMgmt.currenttasks or "snap:upgr:"+package in classnetwork.TasksMgmt.currenttasks or "snap:rm:"+package in classnetwork.TasksMgmt.currenttasks) and not (classnetwork.TasksMgmt.currenttask.startswith("snap:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package)):
                GLib.idle_add(self.change_button_state, "queued", False)
                return
            if classnetwork.snapmgmtimported == True:
                ifinstalled = classnetwork.SnapChecks.checkinstalled(mgmtpkgname)
                if self.current_package == package:
                    if ifinstalled == 1:
                        GLib.idle_add(self.change_button_state, "installed", False)
                        return
                    else:
                        GLib.idle_add(self.change_button_state, "uninstalled", False)
                        return
            else:
                GLib.idle_add(self.change_button_state, "sourcemissing", False)
                return
        
        elif self.current_package_type == "flatpak":
            if classnetwork.TasksMgmt.currenttask.startswith("flatpak:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package):
                GLib.idle_add(self.change_button_state, "busy", False)
                return
            elif ("flatpak:inst:"+package in classnetwork.TasksMgmt.currenttasks or "flatpak:upgr:"+package in classnetwork.TasksMgmt.currenttasks or "flatpak:rm:"+package in classnetwork.TasksMgmt.currenttasks) and not (classnetwork.TasksMgmt.currenttask.startswith("flatpak:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package)):
                GLib.idle_add(self.change_button_state, "queued", False)
                return
            if classnetwork.flatpakmgmtimported == True:
                ifinstalled = classnetwork.FlatpakChecks.checkinstalled(mgmtpkgname, False) #TODO: Add userland Flatpak support (the 'False' = System-wide)
                if self.current_package == package:
                    if ifinstalled == 1 or ifinstalled == 3:
                        GLib.idle_add(self.change_button_state, "installed", False)
                        return
                    else:
                        if classnetwork.FlatpakChecks.checkneedsrepo(mgmtpkgname, classnetwork.JSONReader.availablesources[package]["flatpak"].split("flatpak-")[1], False) != []:
                            GLib.idle_add(self.change_button_state, "sourcemissing", False)
                            return
                        else:
                            GLib.idle_add(self.change_button_state, "uninstalled", False)
                            return
            else:
                GLib.idle_add(self.change_button_state, "sourcemissing", False)
                return

        elif self.current_package_type == "ice":
            GLib.idle_add(self.app_source_dropdown_box.set_visible, False)
            GLib.idle_add(self.change_button_state, "loading", False)
            if os.path.isfile(os.path.expanduser("~")+"/.local/share/applications/feren-ice-ssb-"+package.split("feren-ice-ssb-")[1]+".desktop"):
                GLib.idle_add(self.change_button_state, "installed", False)
                return
            else:
                GLib.idle_add(self.change_button_state, "uninstalled", False)
                if self.sources_visible:
                    GLib.idle_add(self.app_source_dropdown_box.set_visible, True)
                return
                
    def on_installer_finished(self, package):
        #thread = Thread(target=self._on_installer_finished,
        #                args=(package,))
        #thread.daemon = True
        #thread.start()
        pass
    
    def _on_installer_finished(self, package):
        #Tried threads - just crashes
        #GLib.idle_add(self.__on_installer_finished, package)
        pass
            
    def __on_installer_finished(self, package):
        pass
    
    def install_with_source_pressed(self, button):
        #When you press 'Install...'
        pass
    
    def install_pressed(self, button):
        #When you press 'Install'
        self.change_button_state("loading", False)
        if self.current_package_type == "apt":
            if self.current_package == "debfile":
                self.APTMgmt.install_package(sys.argv[1])
            else:
                self.APTMgmt.install_package(self.current_package)
        elif self.current_package_type == "snap":
            classnetwork.SnapMgmt.install_package(self.current_package)
        elif self.current_package_type == "flatpak":
            classnetwork.FlatpakMgmt.install_package(self.current_package, False)
        elif self.current_package_type == "ice":
            tree_iter = self.app_source_dropdown.get_active_iter()
            if tree_iter is not None:
                model = self.app_source_dropdown.get_model()
                active_text = model[tree_iter][0]
                self.ICEMgmt.install(self.current_package, active_text)
    
    def update_pressed(self, button):
        #When you press 'Update'
        self.change_button_state("loading", False)
        if self.current_package_type == "apt":
            self.APTMgmt.upgrade_package(self.current_package)
        elif self.current_package_type == "flatpak":
            classnetwork.FlatpakMgmt.upgrade_package(self.current_package, False)
    
    def remove_pressed(self, button):
        #When you press 'Remove'
        self.change_button_state("loading", False)
        if self.current_package_type == "apt":
            self.APTMgmt.remove_package(self.current_package)
        elif self.current_package_type == "snap":
            classnetwork.SnapMgmt.remove_package(self.current_package)
        elif self.current_package_type == "flatpak":
            classnetwork.FlatpakMgmt.remove_package(self.current_package, False)
        elif self.current_package_type == "ice":
            self.ICEMgmt.remove(self.current_package)

    def cancel_from_queue_pressed(self, button):
        #TODO: Make this work irregardless of package manager
        if not (classnetwork.TasksMgmt.currenttask.startswith(self.current_package_type+":") and classnetwork.TasksMgmt.currenttask.endswith(":"+self.current_package)):
            for taskitem in classnetwork.TasksMgmt.currenttasks[:]:
                if taskitem.startswith(self.current_package_type+":") and taskitem.endswith(":"+self.current_package):
                    classnetwork.TasksMgmt.currenttasks.remove(taskitem)
                    classnetwork.TasksMgmt.gui_refresh_tasks()
                    self.switch_source(self.current_package, self.current_package_type)



####AppView (the website)
class AppView(WebKit2.WebView):

    def __init__(self):
        WebKit2.WebView.__init__(self)
        classnetwork.AppView = self
        
        # Set WebKit background to the same as GTK
        #Update: Nevermind it goes black
        #self.set_background_color(Gdk.RGBA(0, 0, 0, 0))

        self.connect('load-changed', self._load_changed_cb)
        self.connect('context-menu', self._context_menu_cb)
        self.connect('notify::status', self.on_load_status_change)

        self.l_uri = None
        self.status_btn = None
        self.back_btn = None
        #self.set_zoom_level(0.90)

        #For the back button
        #TODO: Check this more rigorously
        self.back_button_history = ["home.html"]

        self.back_signal_handler = None
        
        self.current_package = ""

        self._deb = None
    
        
    def on_load_status_change(download, status):
        print(download, status)
        
        #self._push_config()
        
    def refresh_gtk_colors(self):
        """
        Updates the CSS on the page to use the colours from GTK.
        """
        window = Gtk.Window()
        style_context = window.get_style_context()

        def _rgba_to_hex(color):
           """
           Return hexadecimal string for :class:`Gdk.RGBA` `color`.
           """
           return "#{0:02x}{1:02x}{2:02x}".format(
                                            int(color.red   * 255),
                                            int(color.green * 255),
                                            int(color.blue  * 255))

        def _get_color(style_context, preferred_color, fallback_color):
            color = _rgba_to_hex(style_context.lookup_color(preferred_color)[1])
            if color == "#000000":
                color = _rgba_to_hex(style_context.lookup_color(fallback_color)[1])
            return color

        def _get_hex_variant(string, offset):
            """
            Converts hex input #RRGGBB to RGB and HLS to increase lightness independently
            """
            string = string.lstrip("#")
            rgb = list(int(string[i:i+2], 16) for i in (0, 2 ,4))

            # colorsys module converts to HLS to brighten/darken
            hls = colorsys.rgb_to_hls(rgb[0], rgb[1], rgb[2])
            newbright = hls[1] + offset
            newbright = min([255, max([0, newbright])])
            hls = (hls[0], newbright, hls[2])

            # Re-convert to rgb and hex
            newrgb = colorsys.hls_to_rgb(hls[0], hls[1], hls[2])

            def _validate(value):
                value = int(value)
                if value > 255:
                    return 255
                elif value < 0:
                    return 0
                return value

            newrgb = [_validate(newrgb[0]), _validate(newrgb[1]), _validate(newrgb[2])]
            newhex = '#%02x%02x%02x' % (newrgb[0], newrgb[1], newrgb[2])
            return newhex

        bg_color = _get_color(style_context, "theme_base_color_breeze", "theme_base_color")
        text_color = _get_color(style_context, "theme_fg_color_breeze", "theme_fg_color")
        selected_bg_color = _get_color(style_context, "theme_selected_bg_color_breeze", "theme_selected_bg_color")
        selected_text_color = _get_color(style_context, "theme_selected_fg_color_breeze", "theme_selected_fg_color")
        button_bg_color = _get_color(style_context, "theme_button_background_normal_breeze", "theme_bg_color")

        css = []
        css.append("--bg: " + bg_color)
        css.append("--text: " + text_color)
        css.append("--selected_bg: " + selected_bg_color)
        css.append("--selected_text: " + selected_text_color)
        css.append("--button_bg: linear-gradient(to bottom, {0}, {1})".format(
                                          _get_hex_variant(button_bg_color, 8),
                                          _get_hex_variant(button_bg_color, -8)))

        app.update_page("body", "append", "<style>:root {" + ";".join(css) + "}</style>")

        # For High Contrast theme
        if bg_color in ["#000", "#000000"]:
            app.update_page("body", "addClass", "bg-is-black")

    def toggle_back(self, newstate):
        backbtnthread = Thread(target=self._toggle_back,
                            args=(newstate,))
        backbtnthread.start()
    
    def _toggle_back(self, newstate):
        GLib.idle_add(self.__toggle_back, newstate)
    
    def __toggle_back(self, newstate):
        self.back_btn.set_sensitive(newstate)

    def _back_action(self, data):
        self.toggle_back(False)
        #Remove from back history
        self.back_button_history = self.back_button_history[:-1]
        self.run_javascript('gotopage("'+self.back_button_history[-1]+'")')
        
    def _goto_page(self, page):
        #file = os.path.abspath(os.path.join(translations.get_pages_path(), page+".html"))
        file = os.path.abspath(os.path.join("/usr/share/feren-store-new/"+page+".html"))
        uri = 'file://' + urllib.request.pathname2url(file)
        self.load_uri(uri)
        
    def _goto_packageview(self, packagename):
        #file = os.path.abspath(os.path.join(translations.get_pages_path(), "packagepage.html"))
        self.run_javascript('gotopackage("'+packagename+'")')

    def _btn_goto_packageview(self, btn, packagename):
        self._goto_packageview(packagename)

    def _generate_apps_list(self, category):
        #TODO: Make it category-specific
        for package in classnetwork.JSONReader.internalpkgnames:
            app._run_javascript('mkbutton("'+category+package+'")')

    def _generate_websites_list(self, category):
        #TODO: Make it category-specific
        for package in classnetwork.JSONReader.icedata:
            app._run_javascript('mkbutton("'+category+package+'")')

    def update_insite_information(self, packagename, packagetype):
        #Update in-page items
        if packagename.startswith("feren-ice-ssb-"):
            app_description, app_author, app_bugreporturl, app_website, app_donation, app_tos, app_privpol, app_category, app_image1, app_image2, app_image3 = classnetwork.JSONReader.getPackageSiteInfo(packagename.split("feren-ice-ssb-")[1], "ice")
        elif packagename == ("debfile"):
            app_description, app_author, app_bugreporturl, app_website, app_donation, app_tos, app_privpol, app_category, app_image1, app_image2, app_image3 = self._deb["Description"], self._deb["Maintainer"], None, self._deb["Homepage"], None, None, None, None, None, None, None
        else:
            app_description, app_author, app_bugreporturl, app_website, app_donation, app_tos, app_privpol, app_category, app_image1, app_image2, app_image3 = classnetwork.JSONReader.getPackageSiteInfo(packagename, packagetype)
        
        app.update_page('#description', 'html', app_description)
        app.update_page('#author', 'html', app_author)
        app.update_page('#bugreporturl', 'html', app_bugreporturl)
        app.update_page('#website', 'html', app_website)
        app.update_page('#donation', 'html', app_donation)
        app.update_page('#tos', 'html', app_tos)
        app.update_page('#privpol', 'html', app_privpol)
        app.update_page('#category', 'html', app_category)
        app.update_page('#image1', 'src', app_image1)
        app.update_page('#image2', 'src', app_image2)
        app.update_page('#image3', 'src', app_image3)
            
    def packagepagestuff(self):
        packagetoview = app.current_page.split('packagepage.html?package=')[1]

        if packagetoview != self.current_package:
            self.current_package = packagetoview
            classnetwork.AppDetailsHeader.set_current_package(packagetoview)

            if packagetoview.startswith("feren-ice-ssb-"):
                app_title, app_desc, app_iconurl = classnetwork.JSONReader.getPackageInfo(packagetoview.split("feren-ice-ssb-")[1], "ice")
                classnetwork.AppDetailsHeader.set_app_details(app_title, app_desc)
                classnetwork.AppDetailsHeader.set_package_type("ice")

            elif packagetoview == "debfile":
                import apt.debfile
                self._deb = apt.debfile.DebPackage(sys.argv[1], None)
                app_title, app_desc, app_iconurl = self._deb.pkgname, "Package File", "file://"+RetrieveIconSize.set_icon_string("application-x-deb", 256)
                classnetwork.AppDetailsHeader.set_app_details(app_title, app_desc)
                classnetwork.AppDetailsHeader.set_package_type("apt")

            else:
                app_title, app_desc, app_iconurl = classnetwork.JSONReader.getPackageInfo(packagetoview, classnetwork.JSONReader.availablesources[packagetoview]["order-of-importance"][0])
                classnetwork.AppDetailsHeader.set_app_details(app_title, app_desc)
                classnetwork.AppDetailsHeader.set_package_type(classnetwork.JSONReader.availablesources[packagetoview]["order-of-importance"][0])
            
            appiconthread = Thread(target=classnetwork.AppDetailsHeader.set_icon,
                                args=(app_iconurl, packagetoview))
            appiconthread.start()
            
            #Update the sources combobox
            classnetwork.AppDetailsHeader.get_sources(packagetoview)

    def _push_config(self):
        # TODO: push notification should be connected to angularjs and use a
        # broadcast event any suitable controllers will be able to listen and
        # respond accordingly, for now we just use jQuery to manually toggle
        current_page = app.current_page
        
        if current_page == "home.html":
            self.back_button_history = ["home.html"]

        #Show Welcome banner in Store
        #if systemstate.first_run:
            #app.update_page('.firstrun-only', 'show')

        #if not systemstate.is_online:
            #app.update_page('.offline', 'show')
                
        #Toggle block buttons first
        classnetwork.StoreWindow.gohome_btn.handler_block(classnetwork.StoreWindow.gohome_handle_id)
        classnetwork.StoreWindow.goapps_btn.handler_block(classnetwork.StoreWindow.goapps_handle_id)
        classnetwork.StoreWindow.gothemes_btn.handler_block(classnetwork.StoreWindow.gothemes_handle_id)
        classnetwork.StoreWindow.gowebsites_btn.handler_block(classnetwork.StoreWindow.gowebsites_handle_id)
        classnetwork.StoreWindow.status_btn.handler_block(classnetwork.StoreWindow.status_handle_id)
        #Do their toggles and then unblock
        classnetwork.StoreWindow.gohome_btn.set_active(False)
        classnetwork.StoreWindow.goapps_btn.set_active(False)
        classnetwork.StoreWindow.gothemes_btn.set_active(False)
        classnetwork.StoreWindow.gowebsites_btn.set_active(False)
        classnetwork.StoreWindow.status_btn.set_active(False)
        classnetwork.StoreWindow.gohome_btn.handler_unblock(classnetwork.StoreWindow.gohome_handle_id)
        classnetwork.StoreWindow.goapps_btn.handler_unblock(classnetwork.StoreWindow.goapps_handle_id)
        classnetwork.StoreWindow.gothemes_btn.handler_unblock(classnetwork.StoreWindow.gothemes_handle_id)
        classnetwork.StoreWindow.gowebsites_btn.handler_unblock(classnetwork.StoreWindow.gowebsites_handle_id)
        classnetwork.StoreWindow.status_btn.handler_unblock(classnetwork.StoreWindow.status_handle_id)

        ### Index Page ###
        if current_page == 'statuspage.html':
            classnetwork.StoreWindow.status_btn.handler_block(classnetwork.StoreWindow.status_handle_id)
            classnetwork.StoreWindow.status_btn.set_active(True)
            classnetwork.StoreWindow.status_btn.handler_unblock(classnetwork.StoreWindow.status_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
            
            taskslistthread = Thread(target=classnetwork.TasksMgmt.gui_refresh_tasks,
                                args=())
            taskslistthread.start()
            
            self.pages.set_visible_child(self.sw2)
        else:
            self.pages.set_visible_child(self.sw)
        if current_page == 'home.html' or current_page.startswith('recommendations.html'):
            classnetwork.StoreWindow.gohome_btn.handler_block(classnetwork.StoreWindow.gohome_handle_id)
            classnetwork.StoreWindow.gohome_btn.set_active(True)
            classnetwork.StoreWindow.gohome_btn.handler_unblock(classnetwork.StoreWindow.gohome_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
        elif current_page == 'applicationspage.html':
            classnetwork.StoreWindow.goapps_btn.handler_block(classnetwork.StoreWindow.goapps_handle_id)
            classnetwork.StoreWindow.goapps_btn.set_active(True)
            classnetwork.StoreWindow.goapps_btn.handler_unblock(classnetwork.StoreWindow.goapps_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            
            applistthread = Thread(target=self._generate_apps_list,
                                args=("",))
            applistthread.start()
            classnetwork.AppDetailsHeader.set_visible(False)
        elif current_page == 'themespage.html':
            classnetwork.StoreWindow.gothemes_btn.handler_block(classnetwork.StoreWindow.gothemes_handle_id)
            classnetwork.StoreWindow.gothemes_btn.set_active(True)
            classnetwork.StoreWindow.gothemes_btn.handler_unblock(classnetwork.StoreWindow.gothemes_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
        elif current_page == 'websitespage.html':
            classnetwork.StoreWindow.gowebsites_btn.handler_block(classnetwork.StoreWindow.gowebsites_handle_id)
            classnetwork.StoreWindow.gowebsites_btn.set_active(True)
            classnetwork.StoreWindow.gowebsites_btn.handler_unblock(classnetwork.StoreWindow.gowebsites_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
            
            weblistthread = Thread(target=self._generate_websites_list,
                                args=("feren-ice-ssb-",))
            weblistthread.start()
        elif current_page.startswith('packagepage.html'):
            classnetwork.StoreWindow.gohome_btn.set_visible(False)
            classnetwork.StoreWindow.goapps_btn.set_visible(False)
            classnetwork.StoreWindow.gothemes_btn.set_visible(False)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(False)
            classnetwork.AppDetailsHeader.set_visible(True)
            
            remainingstuffthread = Thread(target=self.packagepagestuff,
                                args=())
            remainingstuffthread.start()

        if not current_page.startswith('packagepage.html'):
            self.current_package = ""
            classnetwork.AppDetailsHeader.current_package = ""
            classnetwork.AppDetailsHeader.current_package_type = ""

        #if current_page == 'home':
            #systemstate.first_run = False

    def _load_changed_cb(self, view, frame):
        self.refresh_gtk_colors()
        uri = str(self.get_uri())
        
        #By making this only run on a fully loaded page we prevent this thing running multiple times in one page load
        if self.get_estimated_load_progress() == 1.0:
            self.toggle_back(uri.rsplit('/', 1)[1] != "home.html")
            #Add page to history if it isn't the latest page in history
            if self.back_button_history[-1] != uri.rsplit('/', 1)[1] and uri.rsplit('/', 1)[1] != "splash.html":
                self.back_button_history.append(uri.rsplit('/', 1)[1])
                

            if uri.rsplit('/', 1)[1] == "splash.html":
                self.back_button_history = ["home.html"]
                self.run_javascript('gotopage("'+classnetwork.StoreWindow._start_page+'")')
                return
            else:
                self.mainwindowstack.set_visible_child(self.mainwindow)
            app.current_page = uri.rsplit('/', 1)[1]
            self._push_config()

    def _context_menu_cb(self, webview, menu, event, htr, user_data=None):
        # Disable context menu.
        return True


####Notifications Thing
class Notifier(object):
    INFO = 0
    ERROR = 1
    SUCCESS = 2
    UPDATES = 3

    def __init__(self, type, message):

        if type == self.INFO:
            icon = "dialog-information"
        elif type == self.ERROR:
            icon = "dialog-error"
        elif type == self.SUCCESS:
            icon = "object-select-symbolic"
        elif type == self.UPDATES:
            icon = "store-updates-pending"
        else:
            icon = type

        self.notification = Notification(_("Store"), message, icon)

    def show(self):
        try:
            self.notification.show()
        except:
            # Some error in showing notification
            print("Failed to show notification")


    #def get_system_info(self, webkit):
        #dbg.stdout('Specs', 'Gathering system specifications...', 0, 3)

        ### Append a failure symbol beforehand in event something goes horribly wrong.
        ##stat_error_msg = _("Could not gather data.")
        ##html_tag = '<a data-toggle=\'tooltip\' data-placement=\'top\' title=\'' + stat_error_msg + '\'><span class=\'fa fa-warning specs-error\'></span></a>'
        ##for element in ['distro', 'kernel', 'motherboard', 'boot-mode', 'cpu-model', 'cpu-speed', 'arch-use',
        ##                'arch-supported', 'memory', 'graphics', 'filesystem', 'capacity', 'allocated-space', 'free-space']:
        ##    app.update_page('#spec'+element, 'html', html_tag)

        ## Adding simple strings. Later this should be converted to translation
        ## supported strings after referring welcome app
        #gb_prefix = _("GB")
        #gib_prefix = _("GiB")
        #mb_prefix = _("MB")
        #mib_prefix = _("MiB")

        ### Root partition (where Distribution is installed) and the rest of that disk.
        #try:
            ### Perform calculations across units
            #capacity_GB =   round(entire_disk/1000/1000/1000,1)
            #capacity_GiB =  round(entire_disk/1024/1024/1024,1)
            #allocated_GB =  round(root_size/1000/1000/1000,1)
            #allocated_GiB = round(root_size/1024/1024/1024,1)
            #used_GB =       round(root_used/1000/1000/1000,1)
            #used_GiB =      round(root_used/1024/1024/1024,1)
            #free_GB =       round(root_free/1000/1000/1000,1)
            #free_GiB =      round(root_free/1024/1024/1024,1)
            #other_GB =      round((entire_disk-root_size)/1000/1000/1000,1)
            #other_GiB =     round((entire_disk-root_size)/1024/1024/1024,1)

            ## Show megabytes/mebibytes (in red) if gigabytes are too small.
            #if capacity_GB <= 1:
                #capacity_GB = str(round(entire_disk/1000/1000,1)) + ' ' + mb_prefix
                #capacity_GiB = str(round(entire_disk/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #capacity_GB = str(capacity_GB) + ' ' + gb_prefix
                #capacity_GiB = str(capacity_GiB) + ' ' + gib_prefix

            #if allocated_GB <= 1:
                #allocated_GB =  str(round(root_size/1000/1000,1)) + ' ' + mb_prefix
                #allocated_GiB = str(round(root_size/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #allocated_GB = str(allocated_GB) + ' ' + gb_prefix
                #allocated_GiB = str(allocated_GiB) + ' ' + gib_prefix

            #if used_GB <= 1:
                #used_GB =  str(round(root_used/1000/1000,1)) + ' ' + mb_prefix
                #used_GiB = str(round(root_used/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #used_GB = str(used_GB) + ' ' + gb_prefix
                #used_GiB = str(used_GiB) + ' ' + gib_prefix

            #if free_GB <= 1:
                #free_GB =  str(round(root_free/1000/1000,1)) + ' ' + mb_prefix
                #free_GiB = str(round(root_free/1024/1024,1)) + ' ' + mib_prefix
                #app.update_page('#spec-free-space', 'addClass', 'specs-error')
            #else:
                #free_GB = str(free_GB) + ' ' + gb_prefix
                #free_GiB = str(free_GiB) + ' ' + gib_prefix

            #if other_GB <= 1:
                #other_GB =  str(round((entire_disk-root_size)/1000/1000,1)) + ' ' + mb_prefix
                #other_GiB = str(round((entire_disk-root_size)/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #other_GB = str(other_GB) + ' ' + gb_prefix
                #other_GiB = str(other_GiB) + ' ' + gib_prefix

                ### Calculate representation across physical disk
                #disk_percent_UM_used = int(round(root_used / entire_disk * 100)) * 2
                #disk_percent_UM_free = int(round(root_free / entire_disk * 100)) * 2
                #disk_percent_other   = (200 - disk_percent_UM_used - disk_percent_UM_free)
                #dbg.stdout('Specs', ' Disk: ' + root_dev, 1, 4)
                #dbg.stdout('Specs', '  -- OS Used: ' + str(root_used) + ' bytes (' + str(disk_percent_UM_used/2) + '%)', 1, 4)
                #dbg.stdout('Specs', '  -- OS Free: ' + str(root_free) + ' bytes (' + str(disk_percent_UM_free/2) + '%)', 1, 4)
                #dbg.stdout('Specs', '  -- Other Partitions: ' + str(entire_disk - root_size) + ' bytes (' + str(disk_percent_other/2) + '%)', 1, 4)
            
        #except Exception as err:
            #print(err)
            #dbg.stdout('Specs', 'Failed to gather data: Storage', 0, 1)


####Class Network - use this at any time to connect any bit of code to any class (that has an init) in this code
class ClassNetwork():
    def __init__(self):
        self.snapmgmtimported = False
        self.flatpakmgmtimported = False
        self.JSONReader = JSONReader()
        self.GlobalVariables = GlobalVariables()
        self.TasksMgmt = TasksMgmt()
        self.SearchHeader = None
        self.AppDetailsHeader = None
        self.AppView = None
        self.Notifier = None
        self.DEBWindow = None
        self.SettingsWindow = None
        self.StoreWindow = None
        self.APTMgmt = None
        self.SnapMgmt = None
        self.SnapChecks = None
        self.FlatpakMgmt = None
        self.FlatpakChecks = None
        self.ICEMgmt = None
        self.import_snap()
        self.import_flatpak()

    def import_snap(self):
        if not os.path.isfile("/usr/bin/snap"): #Abort import if Snap itself isn't installed
            self.snapmgmtimported = False
            return
        if self.snapmgmtimported == True:
            #If it's imported, don't bother reimporting it
            return
        try:
            from feren_store.snapmgmt import SnapMgmt, SnapChecks
            self.SnapMgmt = SnapMgmt(self)
            self.SnapChecks = SnapChecks
            self.snapmgmtimported = True
        except:
            self.snapmgmtimported = False
    def import_flatpak(self):
        if not os.path.isfile("/usr/bin/flatpak"): #Abort import if Flatpak itself isn't installed
            self.flatpakmgmtimported = False
            return
        if self.flatpakmgmtimported == True:
            #If it's imported, don't bother reimporting it
            return
        try:
            from feren_store.flatpakmgmt import FlatpakMgmt, FlatpakChecks
            self.FlatpakMgmt = FlatpakMgmt(self)
            self.FlatpakChecks = FlatpakChecks
            self.flatpakmgmtimported = True
        except:
            self.flatpakmgmtimported = False


####DEBs Checker Window
#class DEBWindow(object):
    #TODO: Add this


####Settings Window
#class SettingsWindow(object):
    #TODO: Add this


class Arguments(object):
    '''Check arguments passed the application.'''

    def __init__(self):
        self.settings_only = False
        self.simulate_arch = None
        self.simulate_no_connection = False
        self.simulate_force_connection = False
        self.simulate_type = None
        self.jump_to_package = False
        self.jump_to_file = False

        if len(sys.argv) < 2:
            return

        if sys.argv[1] == '--help' or sys.argv[1] == '-h':
            print('\nUsage: feren-store-new [arguments]')
            #     | Command                      | Help Text                                     |
            print('  (DEB file goes here)       Open a DEB file in the Feren Store')
            print('  --settings                   Just open Store Settings')
            print('  -h, --help                   Show this help text')
            print('  --simul-arch=ARCH            Simulate a specific architecture.')
            print('                                -- Options: i386, amd64')
            print('  --simul-net                  Simulate a working internet connection.')
            print('  --simul-no-net               Simulate no internet connection.')
            print('  --simul-type=TYPE            Simulate a specific Feren OS type')
            print('                                -- Options: stock, classic')
            print('  (package name goes here)     Jump to an application, by its package name, in the Store')
            print('  -V, --version                Version information')
            print('')
            exit()
        
        elif sys.argv[1] == "--settings":
            print("Opening Feren Store settings...")
            self.settings_only = True
            
        elif sys.argv[1].startswith("--simul-arch"):
            self.simulate_arch = sys.argv[1].split('--simul-arch=')[1]
            if not self.simulate_arch == "i386" and not self.simulate_arch == "amd64":
                print("Unrecognised Architecture:", self.simulate_arch)
                exit()
        
        elif sys.argv[1] == '--force-no-net':
            self.simulate_no_connection = True

        elif sys.argv[1] == '--force-net':
            self.simulate_force_connection = True

        elif sys.argv[1].startswith('--simul-type'):
            self.simulate_version = sys.argv[1].split('--simul-type=')[1]
            if not self.simulate_arch == "stock" and not self.simulate_arch == "classic":
                print("Unrecognised Feren OS Type:", self.simulate_arch)
                exit()
                
        elif sys.argv[1] == "-V" or sys.argv[1] == "--version":
            print("Not implemented yet.")
            exit()
        
        elif sys.argv[1].endswith(".deb") and os.path.isfile(sys.argv[1]):
            print("Go to DEB", sys.argv[1])
            self.jump_to_file = True
        elif sys.argv[1].endswith(".flatpakref") and os.path.isfile(sys.argv[1]):
            print("Go to FlatpakRef", sys.argv[1])
            self.jump_to_file = True
        else:
            print("Go to Package?", sys.argv[1])
            self.jump_to_package = True


####Store Window
class StoreWindow(object):
    def __init__(self):

        self.current_page = ""

        #systemstate.first_run = self._check_first_run()
        #systemstate.first_run = True

        if arg.jump_to_file == True and sys.argv[1].endswith(".deb"):
            self._start_page = 'packagepage.html?package=debfile'
        elif arg.jump_to_file == True and sys.argv[1].endswith(".flatpakref"):
            self._start_page = 'packagepage.html?package=flatpakfile'
        elif arg.jump_to_package == True:
            try: #first try to check it's the internal name
                test = classnetwork.JSONReader.internalpkgnames[sys.argv[1]]
                self._start_page = 'packagepage.html?package='+sys.argv[1]
            except:
                #Now try Appstream, then APT, then Flatpak then Snap
                if classnetwork.JSONReader.getInternalFromName(sys.argv[1], "appstream") != None:
                    self._start_page = 'packagepage.html?package='+classnetwork.JSONReader.getInternalFromName(sys.argv[1], "appstream")
                elif classnetwork.JSONReader.getInternalFromName(sys.argv[1], "apt") != None:
                    self._start_page = 'packagepage.html?package='+classnetwork.JSONReader.getInternalFromName(sys.argv[1], "apt")
                elif classnetwork.JSONReader.getInternalFromName(sys.argv[1], "flatpak") != None:
                    self._start_page = 'packagepage.html?package='+classnetwork.JSONReader.getInternalFromName(sys.argv[1], "flatpak")
                elif classnetwork.JSONReader.getInternalFromName(sys.argv[1], "snap") != None:
                    self._start_page = 'packagepage.html?package='+classnetwork.JSONReader.getInternalFromName(sys.argv[1], "snap")
                else:
                    try: #finally check if it's an ICE package
                        test = classnetwork.JSONReader.icedata[sys.argv[1].split("feren-ice-ssb-")[1]]
                        self._start_page = 'packagepage.html?package='+sys.argv[1]
                    except: #If all of those are exausted, let's just go to the home page.
                        self._start_page = 'home.html'
        else:
            self._start_page = 'home.html'
        
        classnetwork.StoreWindow = self

        self._build_app()

    def build_app_post_splashscreen(self, mainwindow, maintoolbar, mv, b):
        GLib.idle_add(self._build_app_post_splashscreen, mainwindow, maintoolbar, mv, b)

    def _build_app_post_splashscreen(self, mainwindow, maintoolbar, mv, b):
        # build rest of window
        box_application_header = AppDetailsHeader()
        box_application_header.set_visible(False)
        box_application_header.parent_window = self.w
        # add the box to the parent window and show
        mainwindow.pack_start(maintoolbar, False, True, 0)
        mainwindow.pack_start(box_application_header, False, True, 0)
        mainwindow.pack_end(b, True, True, 0)
        file = os.path.abspath(os.path.join("/usr/share/feren-store-new/splash.html"))
        uri = 'file://' + urllib.request.pathname2url(file)
        mv.load_uri(uri)
        self.w.show_all()

    def _build_app(self):
        # build window
        self.w = Gtk.Window()
        self.w.set_position(Gtk.WindowPosition.CENTER)
        self.w.set_title("Store")
        self.w.set_default_size(850, 640)
        self.w.set_size_request(850, 540)
        #self.w.set_resizable(False)

        #This allows Store to be natively recognised as an application associated with its .desktop file
        GLib.set_prgname('/usr/bin/feren-store-new')
        
        back_img = Gtk.Image()
        back_img.set_from_icon_name("go-previous-symbolic", Gtk.IconSize.BUTTON);

        back_btn = Gtk.Button(image=back_img)
        back_btn.set_sensitive(False)
        back_btn.set_name("back-btn")
        
        status_img = Gtk.Image()
        status_img.set_from_icon_name("get-hot-new-stuff", Gtk.IconSize.BUTTON);
        self.status_btn = Gtk.ToggleButton(image=status_img)
        self.status_btn.set_name("status-btn")
        self.status_btn.set_always_show_image(True)
        self.status_handle_id = self.status_btn.connect("clicked", self._status_pressed)
        
        search_img = Gtk.Image()
        search_img.set_from_icon_name("edit-find-symbolic", Gtk.IconSize.BUTTON);
        search_btn = Gtk.ToggleButton(image=search_img)
        search_btn.set_name("search-btn")
        
        mainmenu = Gio.Menu()
        mainmenu.append("hello")
        mainmenu.append("world")
        menu_btn_img = Gtk.Image()
        menu_btn_img.set_from_icon_name("open-menu-symbolic", Gtk.IconSize.BUTTON);
        menu_btn = Gtk.MenuButton(image=menu_btn_img)
        menu_btn.set_use_popover(False)
        menu_btn.set_menu_model(mainmenu)
        
        self.gohome_btn = Gtk.ToggleButton(label=("Home"))
        self.gohome_btn.set_name("gohome-btn")
        self.gohome_handle_id = self.gohome_btn.connect("clicked", self._gohome_pressed)
        
        self.goapps_btn = Gtk.ToggleButton(label=("Applications"))
        self.goapps_btn.set_name("goapps-btn")
        self.goapps_handle_id = self.goapps_btn.connect("clicked", self._goapps_pressed)
        
        self.gothemes_btn = Gtk.ToggleButton(label=("Themes"))
        self.gothemes_btn.set_name("gothemes-btn")
        self.gothemes_handle_id = self.gothemes_btn.connect("clicked", self._gothemes_pressed)
        
        self.gowebsites_btn = Gtk.ToggleButton(label=("Websites"))
        self.gowebsites_btn.set_name("gowebsites-btn")
        self.gowebsites_handle_id = self.gowebsites_btn.connect("clicked", self._gowebsites_pressed)
        
        #For the splash screen
        mainwindowstack = Gtk.Stack()
        mainwindowstack.set_transition_type(Gtk.StackTransitionType.CROSSFADE)

        #Use a titlebar-toolbar approach
        mainwindow = Gtk.VBox()
        mainwindow.set_spacing(0)
        maintoolbar = Gtk.Toolbar()
        maintoolbar.get_style_context().add_class(Gtk.STYLE_CLASS_PRIMARY_TOOLBAR)
        maintoolbar.get_style_context().add_class("only-toolbar")
        maintoolbarcontents = Gtk.ToolItem()
        maintoolbarcontents.set_expand(True)
        maintoolbar.insert(maintoolbarcontents, 0)
        header = Gtk.Box()
        #maintoolbarcontents.set_border_width(2)
        maintoolbarcontents.add(header)
        header.set_spacing(6)
        toolbarspacer=Gtk.Alignment()
        
        #Logo
        logoimageandbox = Gtk.Box(spacing=8)
        logotypebox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        store_logoimg = Gtk.Image()
        store_logoimg.set_from_icon_name("softwarecenter", Gtk.IconSize.DND);
        
        store_logotype1 = Gtk.Label(label=("Feren OS"))
        store_logotype1.get_style_context().add_class("logotype1")
        store_logotype2 = Gtk.Label(label=("Store"))
        store_logotype2.get_style_context().add_class("logotype2")
        
        store_logotype1_box = Gtk.Box()
        store_logotype2_box = Gtk.Box()
        store_logotype1_box.pack_start(store_logotype1, False, False, 0)
        store_logotype2_box.pack_start(store_logotype2, False, False, 0)
        
        logotypebox.pack_start(store_logotype1_box, False, False, 0)
        logotypebox.pack_end(store_logotype2_box, False, False, 0)
        logoimageandbox.pack_start(store_logoimg, False, False, 0)
        logoimageandbox.pack_end(logotypebox, False, False, 0)
            
        header.pack_start(back_btn, False, True, 0)
        header.pack_start(logoimageandbox, False, True, 0)
        header.pack_start(toolbarspacer, True, True, 0)
        
        buttoncentering = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        buttoncenteringbtns = Gtk.Box(spacing=4)
        buttoncentering.set_center_widget(buttoncenteringbtns)
        
        buttoncenteringbtns.pack_start(self.gohome_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.goapps_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.gothemes_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.gowebsites_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.status_btn, False, True, 0)
        buttoncenteringbtns.pack_start(search_btn, False, True, 0)
        buttoncenteringbtns.pack_start(menu_btn, False, True, 0)
        
        header.pack_end(buttoncentering, False, False, 0)
        
        css_provider = Gtk.CssProvider()
        #In case this is Feren OS Classic or another non-Plasma-based Desktop running the Feren Store
        css_provider.load_from_path('/usr/share/feren-store-new/css/fallback.css')
        #Add some spizzas to the Feren Store logo too
        css_provider.load_from_path('/usr/share/feren-store-new/css/application.css')
        screen = Gdk.Screen.get_default()
        style_context = Gtk.StyleContext()
        style_context.add_provider_for_screen(screen, css_provider,
                                          Gtk.STYLE_PROVIDER_PRIORITY_USER)
        
        # build tasks page
        taskspage = Gtk.VBox(spacing=8)
        
        taskslabel_box = Gtk.Box()
        taskslabel = Gtk.Label(label="Currently working on these tasks:")
        taskslabel.get_style_context().add_class("14scale")
        taskslabel_box.pack_start(taskslabel, False, False, 0)
        
        self.tasksitems = Gtk.FlowBox()
        self.tasksitems.set_margin_top(4)
        self.tasksitems.set_margin_bottom(4)
        self.tasksitems.set_min_children_per_line(1)
        self.tasksitems.set_max_children_per_line(1)
        self.tasksitems.set_row_spacing(4)
        self.tasksitems.set_homogeneous(True)
        self.tasksitems.set_valign(Gtk.Align.START)
        
        updateslabel_box = Gtk.Box()
        updateslabel = Gtk.Label(label="Updates are available for:")
        updateslabel.get_style_context().add_class("14scale")
        updateslabel_box.pack_start(updateslabel, False, False, 0)
        
        self.updatesitems = Gtk.FlowBox()
        self.updatesitems.set_margin_top(4)
        self.updatesitems.set_margin_bottom(4)
        self.updatesitems.set_min_children_per_line(1)
        self.updatesitems.set_max_children_per_line(1)
        self.updatesitems.set_row_spacing(4)
        self.updatesitems.set_homogeneous(True)
        self.updatesitems.set_valign(Gtk.Align.START)
        
        installedlabel_box = Gtk.Box()
        installedlabel = Gtk.Label(label="Currently installed:")
        installedlabel.get_style_context().add_class("14scale")
        installedlabel_box.pack_start(installedlabel, False, False, 0)
        
        self.installeditems = Gtk.FlowBox()
        self.installeditems.set_margin_top(4)
        self.installeditems.set_margin_bottom(4)
        self.installeditems.set_min_children_per_line(1)
        self.installeditems.set_max_children_per_line(1)
        self.installeditems.set_row_spacing(4)
        self.installeditems.set_homogeneous(True)
        self.installeditems.set_valign(Gtk.Align.START)
                
        taskspage.pack_start(taskslabel_box, False, True, 0)
        taskspage.pack_start(self.tasksitems, False, True, 0)
        taskspage.pack_start(updateslabel_box, False, True, 0)
        taskspage.pack_start(self.updatesitems, False, True, 0)
        taskspage.pack_start(installedlabel_box, False, True, 0)
        taskspage.pack_start(self.installeditems, False, True, 0)
        
        
        # build 404 page
        self.nfpage = Gtk.VBox(spacing=8)
        
        nfpage_box = Gtk.VBox()
        nfpagelabel = Gtk.Label(label="Not Available")
        nfpagelabel2 = Gtk.Label(label="This item is currently not available or does not exist.")
        nfpagelabel.get_style_context().add_class("14scale")
        nfpage_box.pack_start(nfpagelabel, False, False, 5)
        nfpage_box.pack_end(nfpagelabel2, False, False, 5)
        self.nfpage.set_center_widget(nfpage_box)

        # build splash screen
        self.splashscreen = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        store_splashimg = Gtk.Image()
        iconpath = RetrieveIconSize.set_icon_string("softwarecenter", 128)
        store_splashimg.set_from_pixbuf(GdkPixbuf.Pixbuf.new_from_file(iconpath))
        store_ferenimg = Gtk.Image()
        store_ferenimgpixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/feren-store-new/splashlogo.png")
        store_ferenimg.set_from_pixbuf(store_ferenimgpixbuf)
        self.splashscreen.pack_start(Gtk.Box(), True, False, 0)
        self.splashscreen.pack_start(store_splashimg, False, False, 0)
        self.splashscreen.pack_start(Gtk.Box(), True, False, 0)
        self.splashscreen.pack_start(store_ferenimg, False, False, 0)
        self.splashscreen.set_margin_bottom(44)
        self.splashscreen.set_margin_top(44)
        
        mainwindowstack.add_named(self.splashscreen, "splashscreen")
        mainwindowstack.add_named(mainwindow, "window")
        
        # build webkit container
        mv = AppView()
        mv.get_style_context().add_class(Gtk.STYLE_CLASS_VIEW)
        mv.set_zoom_level(1.0)

        mv.back_btn = back_btn
        mv.back_signal_handler = mv.back_btn.connect("clicked", mv._back_action)
        mv.header = header
        
        #handle_id is needed to block events as otherwise the button active state changes cause button press events to occur (for whatever stupid reason) which ultimately leads to a Stack Overflow as the event code retriggers the event by triggering the button press yet again looping the cycle indefinitely

        # build scrolled window widget and add our appview stack
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        # build another scrolled window widget and add our tasks view
        sw2 = Gtk.ScrolledWindow()
        sw2.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        sw2.get_style_context().add_class(Gtk.STYLE_CLASS_VIEW)
        
        self.pages = Gtk.Stack()
        self.pages.get_style_context().add_class(Gtk.STYLE_CLASS_VIEW)
        self.pages.add_named(sw, "webkit")
        self.pages.add_named(sw2, "tasks")
        self.pages.add_named(self.nfpage, "404")
        taskspage.set_margin_bottom(8)
        taskspage.set_margin_top(8)
        taskspage.set_margin_left(10)
        taskspage.set_margin_right(10)
        
        sw.add(mv)
        sw2.add(taskspage)

        # build a an autoexpanding box and add our scrolled window
        b = Gtk.Box(homogeneous=False, spacing=0)
        b.pack_start(self.pages, expand=True, fill=True, padding=0)
        
        self.w.add(mainwindowstack)
        
        self.w.connect('delete-event', self.close)

        self._window = self.w
        self.webkit = mv

        self.w.show_all()
        
        #Add more variables to mv
        mv.sw = sw
        mv.sw2 = sw2
        mv.pages = self.pages
        mv.mainwindow = mainwindow
        mv.mainwindowstack = mainwindowstack
        
        thread = Thread(target=self.build_app_post_splashscreen,
                        args=(mainwindow, maintoolbar, mv, b))
        thread.daemon = True
        thread.start()

    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()

    def _gohome_pressed(self, gtk_widget):
        self.webkit._goto_page("home")

    def _goapps_pressed(self, gtk_widget):
        self.webkit._goto_page("applicationspage")

    def _gothemes_pressed(self, gtk_widget):
        self.webkit._goto_page("themespage")

    def _gowebsites_pressed(self, gtk_widget):
        self.webkit._goto_page("websitespage")

    def _status_pressed(self, gtk_widget):
        self.webkit._goto_page("statuspage")

    def close(self, p1 = None, p2 = None):
        try:
            os.file.remove(pidfile)
        except:
            pass
        Gtk.main_quit(p1, p2)

    def update_page(self, element, function, parm1=None, parm2=None):
        """ Runs a JavaScript jQuery function on the page,
            ensuring correctly parsed quotes. """
        if parm1 and parm2:
            self.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "', '" + parm2.replace("'", '\\\'') + "')")
        if parm1:
            if not function == 'src':
                self.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "')")
            else:
                #Image replacing requires a special code modification
                self.run_javascript('$("' + element + '").attr' + "('src', '" + parm1.replace("'", '\\\'') + "')")
        else:
            self.run_javascript('$("' + element + '").' + function + '()')

    def run_javascript(self, script):
        thread = Thread(target=self._run_javascript,
                        args=(script,))
        thread.start()

    def _run_javascript(self, script):
        """
        Runs a JavaScript function on the page, regardless of which thread it is called from.
        GTK+ operations must be performed on the same thread to prevent crashes.
        """
        GLib.idle_add(self.__run_javascript, script)

    def __run_javascript(self, script):
        """
        Runs a JavaScript script on the page when invoked from run_javascript()
        """
        self.webkit.run_javascript(script)
        return GLib.SOURCE_REMOVE

    def _check_first_run(self):
        file = os.path.join(localdir, 'firstrun')
        if os.path.exists(file):
            return False
        
        os.mknod(file)
        return True


def desktop_files():
    """ dummy function that is used by the translation system
        to capture the strings in the desktop/*.desktop files
        so that these can be updated when feren-store is
        built with translated Names and Comments
    """

    Name =      _("Store")
    Comment =   _("Get applications for Feren OS")

#Single instance Store
#TODO: Move this to after arguments checks
if not os.path.isfile("/tmp/feren-store-running-"+str(os.getuid())):
    pidfile = open("/tmp/feren-store-running-"+str(os.getuid()), "w")
    pidfile.write(str(os.getpid()))
    pidfile.close()
else:
    pidfile = open("/tmp/feren-store-running-"+str(os.getuid()), "r")
    lastpid = pidfile.read()
    try:
        os.kill(int(lastpid), 0)
        print("The new Feren Store is already running.")
        exit(0)
    except OSError:
        pidfile = open("/tmp/feren-store-running-"+str(os.getuid()), "w")
        pidfile.write(str(os.getpid()))
        pidfile.close()

if __name__ == "__main__":

    arg = Arguments()

    # Local data directory to store backup info
    localdir = os.path.expanduser('~') + '/.config/feren-store'
    if not os.path.isdir(localdir):
        os.makedirs(localdir)

    # Init notification
    #try:
    #    NotifyInit("feren-store-new")
    #except:
    #    print("Failed to initialize notifier")
        
    
    ##Define classnetwork and make it usable across all the code
    global classnetwork 
    classnetwork = ClassNetwork()
    
    
    app = StoreWindow()
    app.run()
