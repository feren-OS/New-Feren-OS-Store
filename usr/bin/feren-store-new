#! /usr/bin/python3
# -*- coding:utf-8 -*-
#
# Copyright 2012-2013 "Korora Project" <dev@kororaproject.org>
# Copyright 2013 "Manjaro Linux" <support@manjaro.org>
# Copyright 2014 Antergos
# Copyright 2016-2020 Ubuntu Mate
# Copyright 2016-2018 Ubuntu Budgie Developers
# Copyright 2016-2020 Feren OS Developers
#
# feren-store is free software: you can redistribute it and/or modify
# it under the temms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Feren Welcome Screen is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Feren Welcome Screen. If not, see <http://www.gnu.org/licenses/>.
#

""" Store for Feren OS """

import gi

gi.require_version('WebKit2', '4.0')

import os
import subprocess
import sys
import urllib.request
import urllib.error
import webbrowser
import socket
import platform
import json
import shutil
import locale
import gettext
import getpass
import signal
import colorsys

from gi.repository import WebKit2, Gtk, Gio, Gdk, GLib, Pango, GObject, GdkPixbuf
from threading import Thread
from queue import Queue, Empty
from notify2 import Notification, init as NotifyInit
from os.path import expanduser

from feren_store.aptmgmt import APTMgmt, APTChecks

import apt

####JSON Reader
class JSONReader():
    '''
    Map some short codes with packages. Install/Remove buttons
    will be represented by short code like #code-remove and
    #code-install. This will allow one to check installation status
    of each package using a loop instead of checking separately
    '''

    def __init__(self):
        with open("/usr/share/feren-store-new/curated/apt/packages.json") as file:
            self.aptdata = json.load(file)
        #with open("/usr/share/feren-store-new/curated/snap/packages.json") as file:
        #    self.snapdata = json.load(file)
        #with open("/usr/share/feren-store-new/curated/flatpak/packages.json") as file:
        #    self.flatpakdata = json.load(file)
        #with open("/usr/share/feren-store-new/curated/ice/packages.json") as file:
        #    self.icedata = json.load(file)
        with open("/usr/share/feren-store-new/curated/sources/packages.json") as file:
            self.availablesources = json.load(file)

    def getPackageInfo(self, packagename):
        #TODO: Change this to have an extra argument for which package type this should be for
        try:
            return self.aptdata[packagename]["realname"], self.aptdata[packagename]["shortdescription"], self.aptdata[packagename]["iconurl"]
        except KeyError:
            return None, None, None
        
    def getPackageSiteInfo(self, packagename):
        #TODO: Change this to have an extra argument for which package type this should be for
        try:
            return self.aptdata[packagename]["description"], self.aptdata[packagename]["author"], self.aptdata[packagename]["bugreporturl"], self.aptdata[packagename]["website"], self.aptdata[packagename]["tos"], self.aptdata[packagename]["category"], self.aptdata[packagename]["image1"], self.aptdata[packagename]["image2"], self.aptdata[packagename]["image3"]
        except KeyError:
            return None, None, None
        
####Source Names translator
class ApplicationSourceTranslator():
    #Class for all things translating an application source internal name into human readable, keyrings and repositories to add
    
    def TranslateToHumanReadable(self, appsourceintname):
        if appsourceintname == "standard":
            return "Standard Install"
        elif appsourceintname == "google-chrome":
            return "Google Chrome Repository"
        elif appsourceintname == "snapstore":
            return "Snapcraft"
        elif appsourceintname == "flatpak-flathub":
            return "Flathub"
        else:
            return appsourceintname
        #TODO: Add more
   

####Global Variables
class GlobalVariables(object):
    def __init__(self):
        self.storagetemplocation = "/tmp/feren-store-"+getpass.getuser()
        #Make the folder if it doesn't exist
        if not os.path.isdir("/tmp/feren-store-"+getpass.getuser()):
            os.mkdir("/tmp/feren-store-"+getpass.getuser())

        
####Application Playlists
#class ApplicationPlaylists():
    #TODO: Add Import and Export code
    

####Package Managers checker - check that the package managers are present
class CheckPackageManagers():
    def check_snap():
        if os.path.isfile("/usr/bin/snap"):
            return True
        else:
            return False
    
    def check_flatpak():
        if os.path.isfile("/usr/bin/flatpak"):
            return True
        else:
            return False
        
    
####GSettings Management - get and set values
#TODO: Check if we even need this class - might be an upstream module that we can just use instead
class GSettingsMgmt():
    def get_value():
        pass
    
    def set_value():
        pass


####Package Tiles
class PackageTile(Gtk.Button):
    def set_icon(self, iconuri, packagename, iconobj):
        tempdir = classnetwork.GlobalVariables.storagetemplocation
                
        desired_width = 48
        desired_height = 48
        try:
            if not iconuri.startswith("file://"):
                #Download the application icon
                if not os.path.isfile(tempdir+"/"+packagename+"-icon"):
                    urllib.request.urlretrieve(iconuri, tempdir+"/"+packagename+"-icon")
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(tempdir+"/"+packagename+"-icon")
            else:
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(iconuri.split('file://')[1])
        except Exception as exceptionstring:
            #TODO: Change to store-missing-icon
            icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/icons/Inspire/256/apps/feren-store.png")
        icon_pixbuf = icon_pixbuf.scale_simple(desired_width, desired_height, GdkPixbuf.InterpType.BILINEAR)
        iconobj.set_from_pixbuf(icon_pixbuf)

    def __init__(self, packagename, packagetype):
        Gtk.Button.__init__(self)

        app_title, app_desc, app_iconurl = classnetwork.JSONReader.getPackageInfo(packagename)

        label_name = Gtk.Label(app_title, xalign=0)
        label_name.get_style_context().add_class("14scale")

        label_summary = Gtk.Label(app_desc)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)

        #Make sure application name and short descriptions are left-aligned in there
        app_title_box = Gtk.Box()
        app_desc_box = Gtk.Box()
        app_title_box.pack_start(label_name, False, False, 0)
        app_desc_box.pack_start(label_summary, False, False, 0)

        #Make the column for application name and short description
        vbox.pack_start(app_title_box, False, False, 0)
        vbox.pack_end(app_desc_box, False, False, 0)
        
        #Stuff for centering items vertically
        centering_titledesc_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        centering_titledesc_box.set_center_widget(vbox)



        #Application Icon
        icon = Gtk.Image()
        icon.set_margin_top(4)
        icon.set_margin_bottom(4)

        self.set_icon(app_iconurl, packagename, icon)

        hbox = Gtk.Box()
        hbox.pack_start(icon, False, False, 4)
        hbox.pack_start(centering_titledesc_box, False, False, 8)

        self.add(hbox)


####Tasks System
class TasksMgmt(object):
    
    def __init__(self):
        self.currenttasks = []
        self.currenttask = ""
        self.dontcontinue = False
        self.inaction = False
        self.existingwidgets = []
        
        GObject.threads_init()
        
    def add_task(self, newtask):
        if not newtask in self.currenttasks:
            self.currenttasks.append(newtask)
            self.gui_refresh_tasks()
        
    def start_now(self):
        #Code for initiating the installation process if it isn't already initialised
        if self.inaction == False:
            self.do_tasks()
        else:
            return
        
    def gui_refresh_tasks(self):
        thread = Thread(target=self._gui_refresh_tasks,
                        args=())
        thread.daemon = True
        thread.start()
    
    def _gui_refresh_tasks(self):
        #Tried threads - just crashes
        GLib.idle_add(self.__gui_refresh_tasks)
    
    def __gui_refresh_tasks(self):
        if len(self.currenttasks) >= 1:
            classnetwork.StoreWindow.status_btn.set_label(str(len(self.currenttasks)))
        else:
            classnetwork.StoreWindow.status_btn.set_label("")
        
        #Destoy the existing widgets
        for child in classnetwork.StoreWindow.tasksitems.get_children():
            classnetwork.StoreWindow.tasksitems.remove(child)
        
        self.existingwidgets = []
        
        for task in self.currenttasks:
            if task.startswith('apt:inst:'):
                packagenm = task.split('apt:inst:')[1]
                tile = PackageTile(packagenm, "apt")
            elif task.startswith('apt:upgr:'):
                packagenm = task.split('apt:upgr:')[1]
                tile = PackageTile(packagenm, "apt")
            elif task.startswith('apt:rm:'):
                packagenm = task.split('apt:rm:')[1]
                tile = PackageTile(packagenm, "apt")
            tile.connect("clicked", classnetwork.AppView._btn_goto_packageview, packagenm)

            box = Gtk.FlowBoxChild(child=tile)
            box.show_all()
            classnetwork.StoreWindow.tasksitems.insert(box, -1)
            
        classnetwork.StoreWindow.tasksitems.show_all()
        classnetwork.StoreWindow.updatesitems.show_all()
        classnetwork.StoreWindow.installeditems.show_all()
        
    def gui_refresh_buttons(self):
        thread = Thread(target=self._gui_refresh_buttons,
                        args=())
        thread.daemon = True
        thread.start()
        
    def _gui_refresh_buttons(self):
        #Tried threads - just crashes
        GLib.idle_add(self.__gui_refresh_buttons)
        
    def __gui_refresh_buttons(self):
        pass
        
        
    def do_task(self, task):
        self.currenttask = task
        #Code for doing the task
        if task.startswith("apt:inst:"):
            if classnetwork.AppDetailsHeader.current_package == task.split('apt:inst:')[1]:
                classnetwork.AppDetailsHeader.change_button_state("busy", False)

            classnetwork.APTMgmt.apt_client.install_packages([task.split('apt:inst:')[1]],
                                        reply_handler=classnetwork.APTMgmt.confirm_changes,
                                        error_handler=classnetwork.APTMgmt.on_error) # dbus.DBusException
            if classnetwork.AppDetailsHeader.current_package == task.split('apt:inst:')[1]:
                classnetwork.AppDetailsHeader.change_button_state("busy", False)
            #Since the do_task thing doesn't hold up code while it's doing it...
            while classnetwork.APTMgmt.changesinaction == False:
                pass
            while classnetwork.APTMgmt.changesinaction == True:
                pass

            self.currenttasks.remove(task)
            self.currenttask = ""
            if classnetwork.AppDetailsHeader.current_package == task.split('apt:inst:')[1]:
                classnetwork.AppDetailsHeader.btns_get_package_status("apt", task.split('apt:inst:')[1])
        elif task.startswith("apt:upgr:"):
            classnetwork.APTMgmt.apt_client.upgrade_packages([task.split('apt:upgr:')[1]],
                                        reply_handler=classnetwork.APTMgmt.confirm_changes,
                                        error_handler=classnetwork.APTMgmt.on_error) # dbus.DBusException
            if classnetwork.AppDetailsHeader.current_package == task.split('apt:upgr:')[1]:
                classnetwork.AppDetailsHeader.change_button_state("busy", False)
            #Since the do_task thing doesn't hold up code while it's doing it...
            while classnetwork.APTMgmt.changesinaction == False:
                pass
            while classnetwork.APTMgmt.changesinaction == True:
                pass

            self.currenttasks.remove(task)
            self.currenttask = ""
            if classnetwork.AppDetailsHeader.current_package == task.split('apt:upgr:')[1]:
                classnetwork.AppDetailsHeader.btns_get_package_status("apt", task.split('apt:upgr:')[1])
        elif task.startswith("apt:rm:"):
            classnetwork.APTMgmt.apt_client.remove_packages([task.split('apt:rm:')[1]],
                                        reply_handler=classnetwork.APTMgmt.confirm_changes,
                                        error_handler=classnetwork.APTMgmt.on_error) # dbus.DBusException
            if classnetwork.AppDetailsHeader.current_package == task.split('apt:rm:')[1]:
                classnetwork.AppDetailsHeader.change_button_state("busy", False)
            #Since the do_task thing doesn't hold up code while it's doing it...
            while classnetwork.APTMgmt.changesinaction == False:
                pass
            while classnetwork.APTMgmt.changesinaction == True:
                pass

            self.currenttasks.remove(task)
            self.currenttask = ""
            if classnetwork.AppDetailsHeader.current_package == task.split('apt:rm:')[1]:
                classnetwork.AppDetailsHeader.btns_get_package_status("apt", task.split('apt:rm:')[1])
        elif task.startswith("flatpak:inst:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("flatpak:upgr:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("flatpak:rm:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("snap:inst:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("snap:upgr:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("snap:rm:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("ice:inst:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("ice:rm:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("apt:aptsource:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        elif task.startswith("flatpak:remote:"):
            pass

            self.currenttasks.remove(task)
            self.currenttask = ""
        
    def do_tasks(self):
        self.inaction = True
        while self.currenttasks != []:
            self.do_task(self.currenttasks[0])
            self.gui_refresh_tasks()
            
        self.inaction = False
        
    def closing_check(self):
        if self.currenttasks != []:
            #Prevent closing and stop the tasks after the existing task is done, followed by closing Store
            pass
        

####Search Header
#class SearchHeader(Gtk.Box):
    #TODO: Add this
    

####Application Details Header
class AppDetailsHeader(Gtk.Box):

    def __init__(self):
        
        Gtk.Box.__init__(self)
        
        classnetwork.AppDetailsHeader = self
        
        self.get_style_context().add_class("only-toolbar")
        
        
        box_application_namedesc = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        
        #Application Icon
        self.app_iconimg = Gtk.Image()
        self.app_iconimg_loading = Gtk.Spinner()
        self.app_iconimg_stack = Gtk.Stack()
        self.app_iconimg_loading_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.app_iconimg_loading_box.set_center_widget(self.app_iconimg_loading)
        self.app_iconimg_stack.add_named(self.app_iconimg_loading_box, "Loading")
        self.app_iconimg_stack.add_named(self.app_iconimg, "AppIcon")
        self.app_iconimg_stack.set_visible_child(self.app_iconimg)
        
        #Application Title
        self.app_title = Gtk.Label()
        self.app_title.get_style_context().add_class("14scale")
        
        #Application Description
        self.app_desc = Gtk.Label()
        
        #Application Management Buttons
        self.app_mgmt_button = Gtk.Stack()
        self.app_mgmt_installbtn = Gtk.Button(label=("Install"))
        self.app_mgmt_installunavailbtn = Gtk.Button(label=("Install..."))
        self.app_mgmt_removebtn = Gtk.Button(label=("Remove"))
        self.app_mgmt_updatebtn = Gtk.Button(label=("Update"))
        self.app_mgmt_installbtn.get_style_context().add_class(Gtk.STYLE_CLASS_SUGGESTED_ACTION)
        self.app_mgmt_installunavailbtn.get_style_context().add_class(Gtk.STYLE_CLASS_SUGGESTED_ACTION)
        self.app_mgmt_updatebtn.get_style_context().add_class(Gtk.STYLE_CLASS_SUGGESTED_ACTION)
        self.app_mgmt_removebtn.get_style_context().add_class(Gtk.STYLE_CLASS_DESTRUCTIVE_ACTION)
        self.app_mgmt_preparingbtns = Gtk.Spinner()
        self.app_mgmt_button.add_named(self.app_mgmt_preparingbtns, "Preparing")
        self.app_mgmt_button.add_named(self.app_mgmt_installbtn, "Standard")
        self.app_mgmt_button.add_named(self.app_mgmt_installunavailbtn, "InstallRepo")
        self.app_mgmt_button.add_named(self.app_mgmt_removebtn, "Remove")
        self.app_mgmt_button.set_visible_child(self.app_mgmt_preparingbtns)
        self.app_mgmt_preparingbtns.start()
        
        #Application Source Combobox
        self.app_source_dropdown = Gtk.ComboBox()
        #NOTE TO SELF: NEVER put this in the dropdown refreshing code - it'll cause duplicated labels
        cell = Gtk.CellRendererText()
        self.app_source_dropdown.pack_start(cell, True)
        self.app_source_dropdown.add_attribute(cell, "text", 0)
        
        #Progress Bar
        self.app_mgmt_progress = Gtk.ProgressBar()
        self.app_mgmt_progress_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.app_mgmt_progress_box.set_center_widget(self.app_mgmt_progress)
        
        #Pending Status
        self.app_mgmt_pending_box = Gtk.Box(spacing=8)
        app_mgmt_pending_labelbox = Gtk.VBox()
        app_mgmt_pending_label = Gtk.Label(label="Queued")
        app_mgmt_pending_cancel = Gtk.Button(label="Cancel")
        app_mgmt_pending_cancel.connect('clicked', self.cancel_from_queue_pressed)
        app_mgmt_pending_labelbox.set_center_widget(app_mgmt_pending_label)
        self.app_mgmt_pending_box.pack_start(app_mgmt_pending_labelbox, False, False, 0)
        self.app_mgmt_pending_box.pack_end(app_mgmt_pending_cancel, False, False, 0)
        self.app_mgmt_button.add_named(self.app_mgmt_pending_box, "Pending")
        
        #Make sure application name and short descriptions are left-aligned in there
        app_title_box = Gtk.Box()
        app_desc_box = Gtk.Box()
        app_title_box.pack_start(self.app_title, False, False, 0)
        app_desc_box.pack_start(self.app_desc, False, False, 0)
        
        #Make the column for application name and short description
        box_application_namedesc.pack_start(app_title_box, False, False, 0)
        box_application_namedesc.pack_end(app_desc_box, False, False, 0)
        
        #Stuff for centering items vertically
        centering_titledesc_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        centering_titledesc_box.set_center_widget(box_application_namedesc)
        centering_btnactions_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        
        inside_btnactions_box = Gtk.Box()
        inside_btnactions_box.pack_start(self.app_source_dropdown, False, False, 4)
        inside_btnactions_box.pack_start(self.app_mgmt_progress_box, False, False, 4)
        inside_btnactions_box.pack_start(self.app_mgmt_updatebtn, False, False, 4)
        inside_btnactions_box.pack_start(self.app_mgmt_button, False, False, 4)
        
        centering_btnactions_box.set_center_widget(inside_btnactions_box)
        
        #Header building
        self.pack_start(self.app_iconimg_stack, False, False, 8)
        self.pack_start(centering_titledesc_box, False, True, 4)
        self.pack_end(centering_btnactions_box, False, True, 4)
        
        #Margins
        self.app_iconimg.set_margin_top(8)
        self.app_iconimg.set_margin_bottom(8)
        
        #Header image temp
        desired_width = 48
        desired_height = 48
        icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/feren-os/logos/blank.png")
        icon_pixbuf = icon_pixbuf.scale_simple(desired_width, desired_height, GdkPixbuf.InterpType.BILINEAR)
        self.app_iconimg.set_from_pixbuf(icon_pixbuf)
        
        #Button Assignment
        self.app_mgmt_installbtn.connect('clicked', self.install_pressed)
        self.app_mgmt_installunavailbtn.connect('clicked', self.install_with_source_pressed)
        self.app_mgmt_updatebtn.connect('clicked', self.update_pressed)
        self.app_mgmt_removebtn.connect('clicked', self.remove_pressed)
        
        #Variables
        self.current_package = ""
        self.sources_visible = True
        
        #Initialize Management
        self.APTMgmt = APTMgmt(classnetwork)
        classnetwork.APTMgmt = self.APTMgmt
        
        GObject.threads_init()
        
    def set_current_package(self, packagename):
        self.current_package = packagename

    def show(self):
        self.set_visible(True)
    
    def hide(self):
        self.set_visible(False)
    
    def set_icon(self, iconuri, packagetoview):
        tempdir = classnetwork.GlobalVariables.storagetemplocation
        
        self.app_iconimg_loading.start()
        self.app_iconimg_stack.set_visible_child(self.app_iconimg_loading_box)
        #Set the icon shown on the package header
                
        desired_width = 48
        desired_height = 48
        try:
            if not iconuri.startswith("file://"):
                #Download the application icon
                if not os.path.isfile(tempdir+"/"+packagetoview+"-icon"):
                    urllib.request.urlretrieve(iconuri, tempdir+"/"+packagetoview+"-icon")
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(tempdir+"/"+packagetoview+"-icon")
            else:
                #Set it as the icon in the Store
                icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file(iconuri.split('file://')[1])
        except Exception as exceptionstring:
            print("Could not retrieve icon for", packagetoview, "-", exceptionstring)
            #TODO: Change to store-missing-icon
            icon_pixbuf = GdkPixbuf.Pixbuf.new_from_file("/usr/share/icons/Inspire/256/apps/feren-store.png")
        icon_pixbuf = icon_pixbuf.scale_simple(desired_width, desired_height, GdkPixbuf.InterpType.BILINEAR)
        self.app_iconimg.set_from_pixbuf(icon_pixbuf)
        self.app_iconimg_stack.set_visible_child(self.app_iconimg)
        self.app_iconimg_loading.stop()
    
    def set_app_details(self, apprname, appshortdesc):
        #Set the application real name (apprname) and short description (appshortdesc) on the package header
        self.app_title.set_label(apprname)
        self.app_desc.set_label(appshortdesc)
    
    def set_source(self, packagesource):
        #Set the application source to the one selected in the source dropdown
        pass
    
    def get_sources(self, jsondata, package):
        #Using the JSON Data from sources/packages.json, populate the sources dropdown according to what's available
        sourcenames, orderofsources = [classnetwork.JSONReader.availablesources[package]["apt"], classnetwork.JSONReader.availablesources[package]["flatpak"], classnetwork.JSONReader.availablesources[package]["snap"]], classnetwork.JSONReader.availablesources[package]["order-of-importance"]
        
        
        iface_list_store = Gtk.ListStore(GObject.TYPE_STRING)
        amount_of_sources = 0
        
        for sourcename in orderofsources:
            if sourcename == "apt":
                #apt source
                friendlysourcename = ApplicationSourceTranslator().TranslateToHumanReadable(sourcenames[0])
                if friendlysourcename:
                    iface_list_store.append([friendlysourcename])
                    amount_of_sources += 1
            elif sourcename == "flatpak":
                #flatpak source
                friendlysourcename = ApplicationSourceTranslator().TranslateToHumanReadable(sourcenames[1])
                if friendlysourcename:
                    iface_list_store.append([friendlysourcename])
                    amount_of_sources += 1
            elif sourcename == "snap":
                #snap source
                friendlysourcename = ApplicationSourceTranslator().TranslateToHumanReadable(sourcenames[2])
                if friendlysourcename:
                    iface_list_store.append([friendlysourcename])
                    amount_of_sources += 1
        
        self.app_source_dropdown.set_model(iface_list_store)
        self.app_source_dropdown.set_active(0)
        if amount_of_sources <= 1:
            self.app_source_dropdown.set_visible(False)
            self.sources_visible = False
        else:
            self.app_source_dropdown.set_visible(True)
            self.sources_visible = True
            
    def change_button_state(self, newstate, disableremove):
        thread = Thread(target=self._change_button_state,
                        args=(newstate, disableremove))
        thread.daemon = True
        thread.start()
        
    def _change_button_state(self, newstate, disableremove):
        GLib.idle_add(self.__change_button_state, newstate, disableremove)
    
    def __change_button_state(self, newstate, disableremove):
        #Change button state between 4 states:
        #uninstalled: Install is visible
        #sourcemissing: Install... is visible
        #installed: Remove is visible
        #updatable: Update and Remove are visible
        
        self.app_mgmt_installbtn.set_sensitive(False)
        self.app_mgmt_installunavailbtn.set_sensitive(False)
        self.app_mgmt_removebtn.set_sensitive(False)
        self.app_mgmt_updatebtn.set_sensitive(False)
        if self.sources_visible:
            self.app_source_dropdown.set_visible(True)
        
        if newstate == "loading":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_preparingbtns.start()
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_preparingbtns)
        elif newstate == "queued":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_preparingbtns.start()
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_pending_box)
        elif newstate == "busy":
            #TODO: Add cancel button for non-running tasks once the tasks system is implemented
            self.app_source_dropdown.set_visible(False)
            self.app_mgmt_progress_box.set_visible(True)
            self.app_mgmt_button.set_visible(False)
        elif newstate == "uninstalled":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_installbtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_installbtn)
            self.app_mgmt_preparingbtns.stop()
        elif newstate == "sourcemissing":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            self.app_mgmt_installunavailbtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_installunavailbtn)
            self.app_mgmt_preparingbtns.stop()
        elif newstate == "installed":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            if disableremove == False:
                self.app_mgmt_removebtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(False)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_removebtn)
            self.app_mgmt_preparingbtns.stop()
        elif newstate == "updatable":
            self.app_mgmt_progress_box.set_visible(False)
            self.app_mgmt_button.set_visible(True)
            if disableremove == False:
                self.app_mgmt_removebtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_sensitive(True)
            self.app_mgmt_updatebtn.set_visible(True)
            self.app_mgmt_button.set_visible_child(self.app_mgmt_removebtn)
            self.app_mgmt_preparingbtns.stop()
    
    def btns_get_package_status(self, packagetype, package):
        #Get the state of the package for changing the buttons presented to the user accordingly - is it installed? does it need an update?
        #packagetype is whether it's native, snap, ice or flatpak
        self.change_button_state("loading", False)
        if packagetype == "apt":
            if ("apt:inst:"+package in classnetwork.TasksMgmt.currenttasks or "apt:upgr:"+package in classnetwork.TasksMgmt.currenttasks or "apt:rm:"+package in classnetwork.TasksMgmt.currenttasks) and not (classnetwork.TasksMgmt.currenttask.startswith("apt:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package)):
                self.change_button_state("queued", False)
                return
            elif classnetwork.TasksMgmt.currenttask.startswith("apt:") and classnetwork.TasksMgmt.currenttask.endswith(":"+package):
                self.change_button_state("busy", False)
                return
            ifinstalled = APTChecks.checkinstalled(package)
            if self.current_package == package:
                if ifinstalled == 1:
                    self.change_button_state("installed", package == "feren-store")
                elif ifinstalled == 3:
                    self.change_button_state("updatable", package == "feren-store")
                elif ifinstalled == 404:
                    classnetwork.StoreWindow.pages.set_visible_child(classnetwork.StoreWindow.nfpage)
                    self.hide()
                else:
                    if APTChecks.checkneedsrepo(package) != []:
                        self.change_button_state("sourcemissing", package == "feren-store")
                    else:
                        self.change_button_state("uninstalled", False)
                
    def on_installer_finished(self, package):
        if self.current_package == package:
            thread = Thread(target=self._on_installer_finished,
                            args=(package,))
            thread.daemon = True
            thread.start()
    
    def _on_installer_finished(self, package):
        #Tried threads - just crashes
        GLib.idle_add(self.__on_installer_finished, package)
            
    def __on_installer_finished(self, package):
        #TODO: Make this work depending on the package type
        self.btns_get_package_status("apt", package)
        self.app_mgmt_progress.set_fraction(0.0)
    
    def install_with_source_pressed(self, button):
        #When you press 'Install...'
        pass
    
    def install_pressed(self, button):
        #When you press 'Install'
        self.change_button_state("loading", False)
        self.APTMgmt.install_package(self.current_package)
    
    def update_pressed(self, button):
        #When you press 'Update'
        self.change_button_state("loading", False)
        self.APTMgmt.upgrade_package(self.current_package)
    
    def remove_pressed(self, button):
        #When you press 'Remove'
        self.change_button_state("loading", False)
        self.APTMgmt.remove_package(self.current_package)

    def cancel_from_queue_pressed(self, button):
        #TODO: Make this work irregardless of package manager
        if not (classnetwork.TasksMgmt.currenttask.startswith("apt:") and classnetwork.TasksMgmt.currenttask.endswith(":"+self.current_package)):
            for taskitem in classnetwork.TasksMgmt.currenttasks[:]:
                if taskitem.startswith("apt:") and taskitem.endswith(":"+self.current_package):
                    classnetwork.TasksMgmt.currenttasks.remove(taskitem)
                    classnetwork.TasksMgmt.gui_refresh_tasks()
                    self.btns_get_package_status("apt", self.current_package)



####AppView (the website)
class AppView(WebKit2.WebView):

    def __init__(self):
        WebKit2.WebView.__init__(self)
        classnetwork.AppView = self
        
        # Set WebKit background to the same as GTK
        #Update: Nevermind it goes black
        #self.set_background_color(Gdk.RGBA(0, 0, 0, 0))

        self.connect('load-changed', self._load_changed_cb)
        self.connect('context-menu', self._context_menu_cb)
        self.connect('notify::status', self.on_load_status_change)

        self.l_uri = None
        self.status_btn = None
        self.back_btn = None
        #self.set_zoom_level(0.90)

        self.back_signal_handler = None
        
        self.current_package = ""
        
        self.add_buttons = True
        
    def on_load_status_change(download, status):
        print(download, status)
        
        #self._push_config()
        
    def refresh_gtk_colors(self):
        """
        Updates the CSS on the page to use the colours from GTK.
        """
        window = Gtk.Window()
        style_context = window.get_style_context()

        def _rgba_to_hex(color):
           """
           Return hexadecimal string for :class:`Gdk.RGBA` `color`.
           """
           return "#{0:02x}{1:02x}{2:02x}".format(
                                            int(color.red   * 255),
                                            int(color.green * 255),
                                            int(color.blue  * 255))

        def _get_color(style_context, preferred_color, fallback_color):
            color = _rgba_to_hex(style_context.lookup_color(preferred_color)[1])
            if color == "#000000":
                color = _rgba_to_hex(style_context.lookup_color(fallback_color)[1])
            return color

        def _get_hex_variant(string, offset):
            """
            Converts hex input #RRGGBB to RGB and HLS to increase lightness independently
            """
            string = string.lstrip("#")
            rgb = list(int(string[i:i+2], 16) for i in (0, 2 ,4))

            # colorsys module converts to HLS to brighten/darken
            hls = colorsys.rgb_to_hls(rgb[0], rgb[1], rgb[2])
            newbright = hls[1] + offset
            newbright = min([255, max([0, newbright])])
            hls = (hls[0], newbright, hls[2])

            # Re-convert to rgb and hex
            newrgb = colorsys.hls_to_rgb(hls[0], hls[1], hls[2])

            def _validate(value):
                value = int(value)
                if value > 255:
                    return 255
                elif value < 0:
                    return 0
                return value

            newrgb = [_validate(newrgb[0]), _validate(newrgb[1]), _validate(newrgb[2])]
            newhex = '#%02x%02x%02x' % (newrgb[0], newrgb[1], newrgb[2])
            return newhex

        bg_color = _get_color(style_context, "theme_base_color_breeze", "theme_base_color")
        text_color = _get_color(style_context, "theme_fg_color_breeze", "theme_fg_color")
        selected_bg_color = _get_color(style_context, "theme_selected_bg_color_breeze", "theme_selected_bg_color")
        selected_text_color = _get_color(style_context, "theme_selected_fg_color_breeze", "theme_selected_fg_color")
        button_bg_color = _get_color(style_context, "theme_button_background_normal_breeze", "theme_bg_color")

        css = []
        css.append("--bg: " + bg_color)
        css.append("--text: " + text_color)
        css.append("--selected_bg: " + selected_bg_color)
        css.append("--selected_text: " + selected_text_color)
        css.append("--button_bg: linear-gradient(to bottom, {0}, {1})".format(
                                          _get_hex_variant(button_bg_color, 8),
                                          _get_hex_variant(button_bg_color, -8)))

        app.update_page("body", "append", "<style>:root {" + ";".join(css) + "}</style>")

        # For High Contrast theme
        if bg_color in ["#000", "#000000"]:
            app.update_page("body", "addClass", "bg-is-black")

    def _back_action(self, data):
        self.add_buttons = False
        self.go_back()
        
    def _goto_page(self, page):
        #file = os.path.abspath(os.path.join(translations.get_pages_path(), page+".html"))
        file = os.path.abspath(os.path.join("/usr/share/feren-store-new/"+page+".html"))
        uri = 'file://' + urllib.request.pathname2url(file)
        self.add_buttons = True
        self.load_uri(uri)
        
    def _goto_packageview(self, packagename):
        #file = os.path.abspath(os.path.join(translations.get_pages_path(), "packagepage.html"))
        self.run_javascript('gotopackage("'+packagename+'")')

    def _btn_goto_packageview(self, btn, packagename):
        self._goto_packageview(packagename)

    def _generate_apps_list(self, category):
        #TODO: Make it category-specific
        for package in classnetwork.JSONReader.aptdata:
            app.run_javascript('mkbutton("'+package+'")')
            
    def packagepagestuff(self):
        packagetoview = app.current_page.split('packagepage.html?package=')[1]
        
        if packagetoview != self.current_package:
            app_title, app_desc, app_iconurl = classnetwork.JSONReader.getPackageInfo(packagetoview)
            classnetwork.AppDetailsHeader.set_app_details(app_title, app_desc)
            
            templocation=classnetwork.GlobalVariables.storagetemplocation
            
            appiconthread = Thread(target=classnetwork.AppDetailsHeader.set_icon,
                                args=(app_iconurl, packagetoview))
            appiconthread.start()
            
            #Update the sources combobox
            classnetwork.AppDetailsHeader.get_sources(classnetwork.JSONReader.availablesources, packagetoview)
            
            self.current_package = packagetoview
            classnetwork.AppDetailsHeader.set_current_package(packagetoview)
            
        #TODO: Replace this with code that detects source type and cts accordingly, instead of just APT
        btnsthread = Thread(target=classnetwork.AppDetailsHeader.btns_get_package_status,
                            args=("apt", packagetoview))
        btnsthread.start()
            
        #Update in-page items
        app_description, app_author, app_bugreporturl, app_website, app_tos, app_category, app_image1, app_image2, app_image3 = classnetwork.JSONReader.getPackageSiteInfo(packagetoview)
        app.update_page('#description', 'html', app_description)
        app.update_page('#author', 'html', app_author)
        app.update_page('#bugreporturl', 'html', app_bugreporturl)
        app.update_page('#website', 'html', app_website)
        app.update_page('#tos', 'html', app_tos)
        app.update_page('#category', 'html', app_category)
        app.update_page('#image1', 'src', app_image1)
        app.update_page('#image2', 'src', app_image2)
        app.update_page('#image3', 'src', app_image3)

    def _push_config(self):
        # TODO: push notification should be connected to angularjs and use a
        # broadcast event any suitable controllers will be able to listen and
        # respond accordingly, for now we just use jQuery to manually toggle
        current_page = app.current_page
        
        if current_page == "home.html":
            self.back_btn.set_sensitive(False)
        else:
            self.back_btn.set_sensitive(True)

        #Show Welcome banner in Store
        #if systemstate.first_run:
            #app.update_page('.firstrun-only', 'show')

        #if not systemstate.is_online:
            #app.update_page('.offline', 'show')
                
        #Toggle block buttons first
        classnetwork.StoreWindow.gohome_btn.handler_block(classnetwork.StoreWindow.gohome_handle_id)
        classnetwork.StoreWindow.goapps_btn.handler_block(classnetwork.StoreWindow.goapps_handle_id)
        classnetwork.StoreWindow.gothemes_btn.handler_block(classnetwork.StoreWindow.gothemes_handle_id)
        classnetwork.StoreWindow.gowebsites_btn.handler_block(classnetwork.StoreWindow.gowebsites_handle_id)
        classnetwork.StoreWindow.status_btn.handler_block(classnetwork.StoreWindow.status_handle_id)
        #Do their toggles and then unblock
        classnetwork.StoreWindow.gohome_btn.set_active(False)
        classnetwork.StoreWindow.goapps_btn.set_active(False)
        classnetwork.StoreWindow.gothemes_btn.set_active(False)
        classnetwork.StoreWindow.gowebsites_btn.set_active(False)
        classnetwork.StoreWindow.status_btn.set_active(False)
        classnetwork.StoreWindow.gohome_btn.handler_unblock(classnetwork.StoreWindow.gohome_handle_id)
        classnetwork.StoreWindow.goapps_btn.handler_unblock(classnetwork.StoreWindow.goapps_handle_id)
        classnetwork.StoreWindow.gothemes_btn.handler_unblock(classnetwork.StoreWindow.gothemes_handle_id)
        classnetwork.StoreWindow.gowebsites_btn.handler_unblock(classnetwork.StoreWindow.gowebsites_handle_id)
        classnetwork.StoreWindow.status_btn.handler_unblock(classnetwork.StoreWindow.status_handle_id)

        ### Index Page ###
        if current_page == 'statuspage.html':
            classnetwork.StoreWindow.status_btn.handler_block(classnetwork.StoreWindow.status_handle_id)
            classnetwork.StoreWindow.status_btn.set_active(True)
            classnetwork.StoreWindow.status_btn.handler_unblock(classnetwork.StoreWindow.status_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
            
            taskslistthread = Thread(target=classnetwork.TasksMgmt.gui_refresh_tasks,
                                args=())
            taskslistthread.start()
            
            self.pages.set_visible_child(self.sw2)
        else:
            self.pages.set_visible_child(app.webkit)
        if current_page == 'home.html' or current_page.startswith('recommendations.html'):
            classnetwork.StoreWindow.gohome_btn.handler_block(classnetwork.StoreWindow.gohome_handle_id)
            classnetwork.StoreWindow.gohome_btn.set_active(True)
            classnetwork.StoreWindow.gohome_btn.handler_unblock(classnetwork.StoreWindow.gohome_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
        elif current_page == 'applicationspage.html':
            classnetwork.StoreWindow.goapps_btn.handler_block(classnetwork.StoreWindow.goapps_handle_id)
            classnetwork.StoreWindow.goapps_btn.set_active(True)
            classnetwork.StoreWindow.goapps_btn.handler_unblock(classnetwork.StoreWindow.goapps_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
            
            if self.add_buttons == True:
                applistthread = Thread(target=self._generate_apps_list,
                                    args=("e",))
                applistthread.start()
        elif current_page == 'themespage.html':
            classnetwork.StoreWindow.gothemes_btn.handler_block(classnetwork.StoreWindow.gothemes_handle_id)
            classnetwork.StoreWindow.gothemes_btn.set_active(True)
            classnetwork.StoreWindow.gothemes_btn.handler_unblock(classnetwork.StoreWindow.gothemes_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
        elif current_page == 'websitespage.html':
            classnetwork.StoreWindow.gowebsites_btn.handler_block(classnetwork.StoreWindow.gowebsites_handle_id)
            classnetwork.StoreWindow.gowebsites_btn.set_active(True)
            classnetwork.StoreWindow.gowebsites_btn.handler_unblock(classnetwork.StoreWindow.gowebsites_handle_id)
            
            classnetwork.StoreWindow.gohome_btn.set_visible(True)
            classnetwork.StoreWindow.goapps_btn.set_visible(True)
            classnetwork.StoreWindow.gothemes_btn.set_visible(True)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(True)
            classnetwork.AppDetailsHeader.set_visible(False)
        elif current_page.startswith('packagepage.html'):
            classnetwork.StoreWindow.gohome_btn.set_visible(False)
            classnetwork.StoreWindow.goapps_btn.set_visible(False)
            classnetwork.StoreWindow.gothemes_btn.set_visible(False)
            classnetwork.StoreWindow.gowebsites_btn.set_visible(False)
            classnetwork.AppDetailsHeader.set_visible(True)
            
            remainingstuffthread = Thread(target=self.packagepagestuff,
                                args=())
            remainingstuffthread.start()

        #if current_page == 'home':
            #systemstate.first_run = False
            
        self.back_signal_handler = self.back_btn.connect("clicked", self._back_action)

    def _load_changed_cb(self, view, frame):
        self.refresh_gtk_colors()
        uri = str(self.get_uri())
        #By making this only run on a fully loaded page we prevent this thing running multiple times in one page load
        if self.get_estimated_load_progress() == 1.0:
            app.current_page = uri.rsplit('/', 1)[1]
            self._push_config()

    def _context_menu_cb(self, webview, menu, event, htr, user_data=None):
        # Disable context menu.
        return True


####Notifications Thing
class Notifier(object):
    INFO = 0
    ERROR = 1
    SUCCESS = 2
    UPDATES = 3

    def __init__(self, type, message):

        if type == self.INFO:
            icon = "dialog-information"
        elif type == self.ERROR:
            icon = "dialog-error"
        elif type == self.SUCCESS:
            icon = "object-select-symbolic"
        elif type == self.UPDATES:
            icon = "store-updates-pending"
        else:
            icon = type

        self.notification = Notification(_("Store"), message, icon)

    def show(self):
        try:
            self.notification.show()
        except:
            # Some error in showing notification
            print("Failed to show notification")


    #def get_system_info(self, webkit):
        #dbg.stdout('Specs', 'Gathering system specifications...', 0, 3)

        ### Append a failure symbol beforehand in event something goes horribly wrong.
        ##stat_error_msg = _("Could not gather data.")
        ##html_tag = '<a data-toggle=\'tooltip\' data-placement=\'top\' title=\'' + stat_error_msg + '\'><span class=\'fa fa-warning specs-error\'></span></a>'
        ##for element in ['distro', 'kernel', 'motherboard', 'boot-mode', 'cpu-model', 'cpu-speed', 'arch-use',
        ##                'arch-supported', 'memory', 'graphics', 'filesystem', 'capacity', 'allocated-space', 'free-space']:
        ##    app.update_page('#spec'+element, 'html', html_tag)

        ## Adding simple strings. Later this should be converted to translation
        ## supported strings after referring welcome app
        #gb_prefix = _("GB")
        #gib_prefix = _("GiB")
        #mb_prefix = _("MB")
        #mib_prefix = _("MiB")

        ### Root partition (where Distribution is installed) and the rest of that disk.
        #try:
            ### Perform calculations across units
            #capacity_GB =   round(entire_disk/1000/1000/1000,1)
            #capacity_GiB =  round(entire_disk/1024/1024/1024,1)
            #allocated_GB =  round(root_size/1000/1000/1000,1)
            #allocated_GiB = round(root_size/1024/1024/1024,1)
            #used_GB =       round(root_used/1000/1000/1000,1)
            #used_GiB =      round(root_used/1024/1024/1024,1)
            #free_GB =       round(root_free/1000/1000/1000,1)
            #free_GiB =      round(root_free/1024/1024/1024,1)
            #other_GB =      round((entire_disk-root_size)/1000/1000/1000,1)
            #other_GiB =     round((entire_disk-root_size)/1024/1024/1024,1)

            ## Show megabytes/mebibytes (in red) if gigabytes are too small.
            #if capacity_GB <= 1:
                #capacity_GB = str(round(entire_disk/1000/1000,1)) + ' ' + mb_prefix
                #capacity_GiB = str(round(entire_disk/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #capacity_GB = str(capacity_GB) + ' ' + gb_prefix
                #capacity_GiB = str(capacity_GiB) + ' ' + gib_prefix

            #if allocated_GB <= 1:
                #allocated_GB =  str(round(root_size/1000/1000,1)) + ' ' + mb_prefix
                #allocated_GiB = str(round(root_size/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #allocated_GB = str(allocated_GB) + ' ' + gb_prefix
                #allocated_GiB = str(allocated_GiB) + ' ' + gib_prefix

            #if used_GB <= 1:
                #used_GB =  str(round(root_used/1000/1000,1)) + ' ' + mb_prefix
                #used_GiB = str(round(root_used/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #used_GB = str(used_GB) + ' ' + gb_prefix
                #used_GiB = str(used_GiB) + ' ' + gib_prefix

            #if free_GB <= 1:
                #free_GB =  str(round(root_free/1000/1000,1)) + ' ' + mb_prefix
                #free_GiB = str(round(root_free/1024/1024,1)) + ' ' + mib_prefix
                #app.update_page('#spec-free-space', 'addClass', 'specs-error')
            #else:
                #free_GB = str(free_GB) + ' ' + gb_prefix
                #free_GiB = str(free_GiB) + ' ' + gib_prefix

            #if other_GB <= 1:
                #other_GB =  str(round((entire_disk-root_size)/1000/1000,1)) + ' ' + mb_prefix
                #other_GiB = str(round((entire_disk-root_size)/1024/1024,1)) + ' ' + mib_prefix
            #else:
                #other_GB = str(other_GB) + ' ' + gb_prefix
                #other_GiB = str(other_GiB) + ' ' + gib_prefix

                ### Calculate representation across physical disk
                #disk_percent_UM_used = int(round(root_used / entire_disk * 100)) * 2
                #disk_percent_UM_free = int(round(root_free / entire_disk * 100)) * 2
                #disk_percent_other   = (200 - disk_percent_UM_used - disk_percent_UM_free)
                #dbg.stdout('Specs', ' Disk: ' + root_dev, 1, 4)
                #dbg.stdout('Specs', '  -- OS Used: ' + str(root_used) + ' bytes (' + str(disk_percent_UM_used/2) + '%)', 1, 4)
                #dbg.stdout('Specs', '  -- OS Free: ' + str(root_free) + ' bytes (' + str(disk_percent_UM_free/2) + '%)', 1, 4)
                #dbg.stdout('Specs', '  -- Other Partitions: ' + str(entire_disk - root_size) + ' bytes (' + str(disk_percent_other/2) + '%)', 1, 4)
            
        #except Exception as err:
            #print(err)
            #dbg.stdout('Specs', 'Failed to gather data: Storage', 0, 1)


####Class Network - use this at any time to connect any bit of code to any class (that has an init) in this code
class ClassNetwork():
    def __init__(self):
        self.JSONReader = JSONReader()
        self.GlobalVariables = GlobalVariables()
        self.TasksMgmt = TasksMgmt()
        self.SearchHeader = None
        self.AppDetailsHeader = None
        self.AppView = None
        self.Notifier = None
        self.DEBWindow = None
        self.SettingsWindow = None
        self.StoreWindow = None
        self.APTMgmt = None
        self.SnapMgmt = None
        self.FlatpakMgmt = None
        self.ICEMgmt = None


####DEBs Checker Window
#class DEBWindow(object):
    #TODO: Add this


####Settings Window
#class SettingsWindow(object):
    #TODO: Add this


####Store Window
class StoreWindow(object):
    
    def check_arguments(self):
        self.settings_only = False
        self.simulate_arch = None
        self.simulate_no_connection = False
        self.simulate_force_connection = False
        self.simulate_type = None
        self.jump_to_package = False

        for arg in sys.argv:
            if arg == '--help' or arg == '-h':
                print('\nUsage: feren-store-new [arguments]')
                #     | Command                      | Help Text                                     |
                print('  (DEB file goes here)       Open a DEB file in the Feren Store')
                print('  --settings                   Just open Store Settings')
                print('  -h, --help                   Show this help text')
                print('  --simul-arch=ARCH            Simulate a specific architecture.')
                print('                                -- Options: i386, amd64')
                print('  --simul-net                  Simulate a working internet connection.')
                print('  --simul-no-net               Simulate no internet connection.')
                print('  --simul-type=TYPE            Simulate a specific Feren OS type')
                print('                                -- Options: stock, classic')
                print('  (package name goes here)     Jump to an application, by its package name, in the Store')
                print('  -V, --version                Version information')
                print('')
                exit()
              
            elif arg == "--settings":
                print("Opening Feren Store settings...")
                self.settings_only = True
                
            elif arg.startswith("--simul-arch"):
                self.simulate_arch = arg.split('--simul-arch=')[1]
                if not self.simulate_arch == "i386" and not self.simulate_arch == "amd64":
                    print("Unrecognised Architecture:", self.simulate_arch)
                    exit()
            
            elif arg == '--force-no-net':
                self.simulate_no_connection = True

            elif arg == '--force-net':
                self.simulate_force_connection = True

            elif arg.startswith('--simul-type'):
                self.simulate_version = arg.split('--simul-type=')[1]
                if not self.simulate_arch == "stock" and not self.simulate_arch == "classic":
                    print("Unrecognised Feren OS Type:", self.simulate_arch)
                    exit()
                    
            elif arg == "-V" or arg == "--version":
                print("Not implemented yet.")
                exit()
            
            else:
                print("Not implemented yet.")


    def __init__(self):
        
        self.check_arguments()

        self.current_page = ""

        #systemstate.first_run = self._check_first_run()
        #systemstate.first_run = True

        #self.json_path = self._data_path + "/config/packages.json"

        self._start_page = 'home.html'
        #TODO: Add redirect to package page if jump_to_package is True
        
        classnetwork.StoreWindow = self

        self._build_app()

    def _build_app(self):
        # build window
        self.w = Gtk.Window()
        self.w.set_position(Gtk.WindowPosition.CENTER)
        self.w.set_title("Store")
        self.w.set_default_size(810, 640)
        #self.w.set_resizable(False)

        #This allows Store to be natively recognised as an application associated with its .desktop file
        GLib.set_prgname('/usr/bin/feren-store-new')
        
        back_img = Gtk.Image()
        back_img.set_from_icon_name("go-previous-symbolic", Gtk.IconSize.BUTTON);

        back_btn = Gtk.Button(image=back_img)
        back_btn.set_sensitive(False)
        back_btn.set_name("back-btn")
        
        status_img = Gtk.Image()
        status_img.set_from_icon_name("get-hot-new-stuff", Gtk.IconSize.BUTTON);
        self.status_btn = Gtk.ToggleButton(image=status_img)
        self.status_btn.set_name("status-btn")
        self.status_btn.set_always_show_image(True)
        self.status_handle_id = self.status_btn.connect("clicked", self._status_pressed)
        
        search_img = Gtk.Image()
        search_img.set_from_icon_name("edit-find-symbolic", Gtk.IconSize.BUTTON);
        search_btn = Gtk.ToggleButton(image=search_img)
        search_btn.set_name("search-btn")
        
        mainmenu = Gio.Menu()
        mainmenu.append("hello")
        mainmenu.append("world")
        menu_btn_img = Gtk.Image()
        menu_btn_img.set_from_icon_name("open-menu-symbolic", Gtk.IconSize.BUTTON);
        menu_btn = Gtk.MenuButton(image=menu_btn_img)
        menu_btn.set_use_popover(False)
        menu_btn.set_menu_model(mainmenu)
        
        self.gohome_btn = Gtk.ToggleButton(label=("Home"))
        self.gohome_btn.set_name("gohome-btn")
        self.gohome_btn.set_active(True)
        self.gohome_handle_id = self.gohome_btn.connect("clicked", self._gohome_pressed)
        
        self.goapps_btn = Gtk.ToggleButton(label=("Applications"))
        self.goapps_btn.set_name("goapps-btn")
        self.goapps_handle_id = self.goapps_btn.connect("clicked", self._goapps_pressed)
        
        self.gothemes_btn = Gtk.ToggleButton(label=("Themes"))
        self.gothemes_btn.set_name("gothemes-btn")
        self.gothemes_handle_id = self.gothemes_btn.connect("clicked", self._gothemes_pressed)
        
        self.gowebsites_btn = Gtk.ToggleButton(label=("Websites"))
        self.gowebsites_btn.set_name("gowebsites-btn")
        self.gowebsites_handle_id = self.gowebsites_btn.connect("clicked", self._gowebsites_pressed)
        

        #Use a titlebar-toolbar approach
        mainwindow = Gtk.VBox()
        mainwindow.set_spacing(0)
        maintoolbar = Gtk.Toolbar()
        maintoolbar.get_style_context().add_class(Gtk.STYLE_CLASS_PRIMARY_TOOLBAR)
        maintoolbar.get_style_context().add_class("only-toolbar")
        maintoolbarcontents = Gtk.ToolItem()
        maintoolbarcontents.set_expand(True)
        maintoolbar.insert(maintoolbarcontents, 0)
        header = Gtk.Box()
        #maintoolbarcontents.set_border_width(2)
        maintoolbarcontents.add(header)
        header.set_spacing(6)
        toolbarspacer=Gtk.Alignment()
        
        #Logo
        logoimageandbox = Gtk.Box(spacing=8)
        logotypebox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        store_logoimg = Gtk.Image()
        store_logoimg.set_from_icon_name("softwarecenter", Gtk.IconSize.DND);
        
        store_logotype1 = Gtk.Label(label=("Feren OS"))
        store_logotype1.get_style_context().add_class("logotype1")
        store_logotype2 = Gtk.Label(label=("Store"))
        store_logotype2.get_style_context().add_class("logotype2")
        
        store_logotype1_box = Gtk.Box()
        store_logotype2_box = Gtk.Box()
        store_logotype1_box.pack_start(store_logotype1, False, False, 0)
        store_logotype2_box.pack_start(store_logotype2, False, False, 0)
        
        logotypebox.pack_start(store_logotype1_box, False, False, 0)
        logotypebox.pack_end(store_logotype2_box, False, False, 0)
        logoimageandbox.pack_start(store_logoimg, False, False, 0)
        logoimageandbox.pack_end(logotypebox, False, False, 0)
            
        header.pack_start(back_btn, False, True, 0)
        header.pack_start(logoimageandbox, False, True, 0)
        header.pack_start(toolbarspacer, True, True, 0)
        
        buttoncentering = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        buttoncenteringbtns = Gtk.Box(spacing=4)
        buttoncentering.set_center_widget(buttoncenteringbtns)
        
        buttoncenteringbtns.pack_start(self.gohome_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.goapps_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.gothemes_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.gowebsites_btn, False, True, 0)
        buttoncenteringbtns.pack_start(self.status_btn, False, True, 0)
        buttoncenteringbtns.pack_start(search_btn, False, True, 0)
        buttoncenteringbtns.pack_start(menu_btn, False, True, 0)
        
        header.pack_end(buttoncentering, False, False, 0)
        
        css_provider = Gtk.CssProvider()
        #In case this is Feren OS Classic or another non-Plasma-based Desktop running the Feren Store
        css_provider.load_from_path('/usr/share/feren-store-new/css/fallback.css')
        #Add some spizzas to the Feren Store logo too
        css_provider.load_from_path('/usr/share/feren-store-new/css/application.css')
        screen = Gdk.Screen.get_default()
        style_context = Gtk.StyleContext()
        style_context.add_provider_for_screen(screen, css_provider,
                                          Gtk.STYLE_PROVIDER_PRIORITY_USER)
        
        # build tasks page
        taskspage = Gtk.VBox(spacing=8)
        
        taskslabel_box = Gtk.Box()
        taskslabel = Gtk.Label(label="Currently working on these tasks:")
        taskslabel.get_style_context().add_class("14scale")
        taskslabel_box.pack_start(taskslabel, False, False, 0)
        
        self.tasksitems = Gtk.FlowBox()
        self.tasksitems.set_margin_top(4)
        self.tasksitems.set_margin_bottom(4)
        self.tasksitems.set_min_children_per_line(1)
        self.tasksitems.set_max_children_per_line(1)
        self.tasksitems.set_row_spacing(4)
        self.tasksitems.set_homogeneous(True)
        self.tasksitems.set_valign(Gtk.Align.START)
        
        updateslabel_box = Gtk.Box()
        updateslabel = Gtk.Label(label="Updates are available for:")
        updateslabel.get_style_context().add_class("14scale")
        updateslabel_box.pack_start(updateslabel, False, False, 0)
        
        self.updatesitems = Gtk.FlowBox()
        self.updatesitems.set_margin_top(4)
        self.updatesitems.set_margin_bottom(4)
        self.updatesitems.set_min_children_per_line(1)
        self.updatesitems.set_max_children_per_line(1)
        self.updatesitems.set_row_spacing(4)
        self.updatesitems.set_homogeneous(True)
        self.updatesitems.set_valign(Gtk.Align.START)
        
        installedlabel_box = Gtk.Box()
        installedlabel = Gtk.Label(label="Currently installed:")
        installedlabel.get_style_context().add_class("14scale")
        installedlabel_box.pack_start(installedlabel, False, False, 0)
        
        self.installeditems = Gtk.FlowBox()
        self.installeditems.set_margin_top(4)
        self.installeditems.set_margin_bottom(4)
        self.installeditems.set_min_children_per_line(1)
        self.installeditems.set_max_children_per_line(1)
        self.installeditems.set_row_spacing(4)
        self.installeditems.set_homogeneous(True)
        self.installeditems.set_valign(Gtk.Align.START)
                
        taskspage.pack_start(taskslabel_box, False, True, 0)
        taskspage.pack_start(self.tasksitems, False, True, 0)
        taskspage.pack_start(updateslabel_box, False, True, 0)
        taskspage.pack_start(self.updatesitems, False, True, 0)
        taskspage.pack_start(installedlabel_box, False, True, 0)
        taskspage.pack_start(self.installeditems, False, True, 0)
        
        
        # build 404 page
        self.nfpage = Gtk.VBox(spacing=8)
        
        nfpage_box = Gtk.VBox()
        nfpagelabel = Gtk.Label(label="Not Available")
        nfpagelabel2 = Gtk.Label(label="This item is currently not available or does not exist.")
        nfpagelabel.get_style_context().add_class("14scale")
        nfpage_box.pack_start(nfpagelabel, False, False, 5)
        nfpage_box.pack_end(nfpagelabel2, False, False, 5)
        self.nfpage.set_center_widget(nfpage_box)
        
        
        # build webkit container
        mv = AppView()
        mv.get_style_context().add_class(Gtk.STYLE_CLASS_VIEW)
        mv.set_zoom_level(1.0)

        mv.back_btn = back_btn
        
        #handle_id is needed to block events as otherwise the button active state changes cause button press events to occur (for whatever stupid reason) which ultimately leads to a Stack Overflow as the event code retriggers the event by triggering the button press yet again looping the cycle indefinitely

        # load our index file
        #file = os.path.abspath(os.path.join(translations.get_pages_path(), self._start_page))
        file = os.path.abspath(os.path.join("/usr/share/feren-store-new/"+self._start_page))
        uri = 'file://' + urllib.request.pathname2url(file)
        mv.load_uri(uri)

        # build scrolled window widget and add our appview stack
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        
        # build another scrolled window widget and add our tasks view
        sw2 = Gtk.ScrolledWindow()
        sw2.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        sw2.get_style_context().add_class(Gtk.STYLE_CLASS_VIEW)
        
        self.pages = Gtk.Stack()
        self.pages.get_style_context().add_class(Gtk.STYLE_CLASS_VIEW)
        self.pages.add_named(mv, "webkit")
        self.pages.add_named(sw2, "tasks")
        self.pages.add_named(self.nfpage, "404")
        taskspage.set_margin_bottom(8)
        taskspage.set_margin_top(8)
        taskspage.set_margin_left(10)
        taskspage.set_margin_right(10)
        
        sw.add(self.pages)
        sw2.add(taskspage)

        # build a an autoexpanding box and add our scrolled window
        b = Gtk.Box(homogeneous=False, spacing=0)
        b.pack_start(sw, expand=True, fill=True, padding=0)
        
        box_application_header = AppDetailsHeader()

        # add the box to the parent window and show
        mainwindow.pack_start(maintoolbar, False, True, 0)
        mainwindow.pack_start(box_application_header, False, True, 0)
        mainwindow.pack_end(b, True, True, 0)
        self.w.add(mainwindow)
        
        self.w.connect('delete-event', self.close)
        self.w.show_all()

        self._window = self.w
        self.webkit = mv
        
        #Add more variables to mv
        mv.sw2 = sw2
        mv.pages = self.pages
        
        box_application_header.set_visible(False)
        box_application_header.parent_window = self.w

    def run(self):
        signal.signal(signal.SIGINT, signal.SIG_DFL)
        Gtk.main()

    def _gohome_pressed(self, gtk_widget):
        self.webkit._goto_page("home")

    def _goapps_pressed(self, gtk_widget):
        self.webkit._goto_page("applicationspage")

    def _gothemes_pressed(self, gtk_widget):
        self.webkit._goto_page("themespage")

    def _gowebsites_pressed(self, gtk_widget):
        self.webkit._goto_page("websitespage")

    def _status_pressed(self, gtk_widget):
        self.webkit._goto_page("statuspage")

    def close(self, p1 = None, p2 = None):
        Gtk.main_quit(p1, p2)

    def update_page(self, element, function, parm1=None, parm2=None):
        """ Runs a JavaScript jQuery function on the page,
            ensuring correctly parsed quotes. """
        if parm1 and parm2:
            self.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "', '" + parm2.replace("'", '\\\'') + "')")
        if parm1:
            if not function == 'src':
                self.run_javascript('$("' + element + '").' + function + "('" + parm1.replace("'", '\\\'') + "')")
            else:
                #Image replacing requires a special code modification
                self.run_javascript('$("' + element + '").attr' + "('src', '" + parm1.replace("'", '\\\'') + "')")
        else:
            self.run_javascript('$("' + element + '").' + function + '()')

    def run_javascript(self, script):
        """
        Runs a JavaScript function on the page, regardless of which thread it is called from.
        GTK+ operations must be performed on the same thread to prevent crashes.
        """
        GLib.idle_add(self._run_javascript, script)

    def _run_javascript(self, script):
        """
        Runs a JavaScript script on the page when invoked from run_javascript()
        """
        self.webkit.run_javascript(script)
        return GLib.SOURCE_REMOVE

    def _check_first_run(self):
        file = os.path.join(localdir, 'firstrun')
        if os.path.exists(file):
            return False
        
        os.mknod(file)
        return True


def desktop_files():
    """ dummy function that is used by the translation system
        to capture the strings in the desktop/*.desktop files
        so that these can be updated when feren-store is
        built with translated Names and Comments
    """

    Name =      _("Store")
    Comment =   _("Get applications for Feren OS")


if __name__ == "__main__":

    # Local data directory to store backup info
    localdir = os.path.expanduser('~') + '/.config/feren-store'
    if not os.path.isdir(localdir):
        os.makedirs(localdir)

    # Init notification
    #try:
    #    NotifyInit("feren-store-new")
    #except:
    #    print("Failed to initialize notifier")
        
    
    ##Define classnetwork and make it usable across all the code
    global classnetwork 
    classnetwork = ClassNetwork()
    
    
    app = StoreWindow()
    app.run()
